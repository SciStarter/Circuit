{"mappings":"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","sources":["templates/htmx.js"],"sourcesContent":["// UMD insanity\n// This code sets up support for (in order) AMD, ES6 modules, and globals.\n(function (root, factory) {\n    //@ts-ignore\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        //@ts-ignore\n        define([], factory);\n    } else if (typeof module === 'object' && module.exports) {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory();\n    } else {\n        // Browser globals\n        root.htmx = root.htmx || factory();\n    }\n}(typeof self !== 'undefined' ? self : this, function () {\nreturn (function () {\n        'use strict';\n\n        // Public API\n        //** @type {import(\"./htmx\").HtmxApi} */\n        // TODO: list all methods in public API\n        var htmx = {\n            onLoad: onLoadHelper,\n            process: processNode,\n            on: addEventListenerImpl,\n            off: removeEventListenerImpl,\n            trigger : triggerEvent,\n            ajax : ajaxHelper,\n            find : find,\n            findAll : findAll,\n            closest : closest,\n            values : function(elt, type){\n                var inputValues = getInputValues(elt, type || \"post\");\n                return inputValues.values;\n            },\n            remove : removeElement,\n            addClass : addClassToElement,\n            removeClass : removeClassFromElement,\n            toggleClass : toggleClassOnElement,\n            takeClass : takeClassForElement,\n            defineExtension : defineExtension,\n            removeExtension : removeExtension,\n            logAll : logAll,\n            logger : null,\n            config : {\n                historyEnabled:true,\n                historyCacheSize:10,\n                refreshOnHistoryMiss:false,\n                defaultSwapStyle:'innerHTML',\n                defaultSwapDelay:0,\n                defaultSettleDelay:20,\n                includeIndicatorStyles:true,\n                indicatorClass:'htmx-indicator',\n                requestClass:'htmx-request',\n                addedClass:'htmx-added',\n                settlingClass:'htmx-settling',\n                swappingClass:'htmx-swapping',\n                allowEval:true,\n                inlineScriptNonce:'',\n                attributesToSettle:[\"class\", \"style\", \"width\", \"height\"],\n                withCredentials:false,\n                timeout:0,\n                wsReconnectDelay: 'full-jitter',\n                wsBinaryType: 'blob',\n                disableSelector: \"[hx-disable], [data-hx-disable]\",\n                useTemplateFragments: false,\n                scrollBehavior: 'smooth',\n                defaultFocusScroll: false,\n                getCacheBusterParam: false,\n            },\n            parseInterval:parseInterval,\n            _:internalEval,\n            createEventSource: function(url){\n                return new EventSource(url, {withCredentials:true})\n            },\n            createWebSocket: function(url){\n                var sock = new WebSocket(url, []);\n                sock.binaryType = htmx.config.wsBinaryType;\n                return sock;\n            },\n            version: \"1.8.6\"\n        };\n\n        /** @type {import(\"./htmx\").HtmxInternalApi} */\n        var internalAPI = {\n            addTriggerHandler: addTriggerHandler,\n            bodyContains: bodyContains,\n            canAccessLocalStorage: canAccessLocalStorage,\n            filterValues: filterValues,\n            hasAttribute: hasAttribute,\n            getAttributeValue: getAttributeValue,\n            getClosestMatch: getClosestMatch,\n            getExpressionVars: getExpressionVars,\n            getHeaders: getHeaders,\n            getInputValues: getInputValues,\n            getInternalData: getInternalData,\n            getSwapSpecification: getSwapSpecification,\n            getTriggerSpecs: getTriggerSpecs,\n            getTarget: getTarget,\n            makeFragment: makeFragment,\n            mergeObjects: mergeObjects,\n            makeSettleInfo: makeSettleInfo,\n            oobSwap: oobSwap,\n            selectAndSwap: selectAndSwap,\n            settleImmediately: settleImmediately,\n            shouldCancel: shouldCancel,\n            triggerEvent: triggerEvent,\n            triggerErrorEvent: triggerErrorEvent,\n            withExtensions: withExtensions,\n        }\n\n        var VERBS = ['get', 'post', 'put', 'delete', 'patch'];\n        var VERB_SELECTOR = VERBS.map(function(verb){\n            return \"[hx-\" + verb + \"], [data-hx-\" + verb + \"]\"\n        }).join(\", \");\n\n        //====================================================================\n        // Utilities\n        //====================================================================\n\n        function parseInterval(str) {\n            if (str == undefined)  {\n                return undefined\n            }\n            if (str.slice(-2) == \"ms\") {\n                return parseFloat(str.slice(0,-2)) || undefined\n            }\n            if (str.slice(-1) == \"s\") {\n                return (parseFloat(str.slice(0,-1)) * 1000) || undefined\n            }\n            if (str.slice(-1) == \"m\") {\n                return (parseFloat(str.slice(0,-1)) * 1000 * 60) || undefined\n            }\n            return parseFloat(str) || undefined\n        }\n\n        /**\n         * @param {HTMLElement} elt\n         * @param {string} name\n         * @returns {(string | null)}\n         */\n        function getRawAttribute(elt, name) {\n            return elt.getAttribute && elt.getAttribute(name);\n        }\n\n        // resolve with both hx and data-hx prefixes\n        function hasAttribute(elt, qualifiedName) {\n            return elt.hasAttribute && (elt.hasAttribute(qualifiedName) ||\n                elt.hasAttribute(\"data-\" + qualifiedName));\n        }\n\n        /**\n         *\n         * @param {HTMLElement} elt\n         * @param {string} qualifiedName\n         * @returns {(string | null)}\n         */\n        function getAttributeValue(elt, qualifiedName) {\n            return getRawAttribute(elt, qualifiedName) || getRawAttribute(elt, \"data-\" + qualifiedName);\n        }\n\n        /**\n         * @param {HTMLElement} elt\n         * @returns {HTMLElement | null}\n         */\n        function parentElt(elt) {\n            return elt.parentElement;\n        }\n\n        /**\n         * @returns {Document}\n         */\n        function getDocument() {\n            return document;\n        }\n\n        /**\n         * @param {HTMLElement} elt\n         * @param {(e:HTMLElement) => boolean} condition\n         * @returns {HTMLElement | null}\n         */\n        function getClosestMatch(elt, condition) {\n            while (elt && !condition(elt)) {\n                elt = parentElt(elt);\n            }\n\n            return elt ? elt : null;\n        }\n\n        function getAttributeValueWithDisinheritance(initialElement, ancestor, attributeName){\n            var attributeValue = getAttributeValue(ancestor, attributeName);\n            var disinherit = getAttributeValue(ancestor, \"hx-disinherit\");\n            if (initialElement !== ancestor && disinherit && (disinherit === \"*\" || disinherit.split(\" \").indexOf(attributeName) >= 0)) {\n                return \"unset\";\n            } else {\n                return attributeValue\n            }\n        }\n\n        /**\n         * @param {HTMLElement} elt\n         * @param {string} attributeName\n         * @returns {string | null}\n         */\n        function getClosestAttributeValue(elt, attributeName) {\n            var closestAttr = null;\n            getClosestMatch(elt, function (e) {\n                return closestAttr = getAttributeValueWithDisinheritance(elt, e, attributeName);\n            });\n            if (closestAttr !== \"unset\") {\n                return closestAttr;\n            }\n        }\n\n        /**\n         * @param {HTMLElement} elt\n         * @param {string} selector\n         * @returns {boolean}\n         */\n        function matches(elt, selector) {\n            // @ts-ignore: non-standard properties for browser compatability\n            // noinspection JSUnresolvedVariable\n            var matchesFunction = elt.matches || elt.matchesSelector || elt.msMatchesSelector || elt.mozMatchesSelector || elt.webkitMatchesSelector || elt.oMatchesSelector;\n            return matchesFunction && matchesFunction.call(elt, selector);\n        }\n\n        /**\n         * @param {string} str\n         * @returns {string}\n         */\n        function getStartTag(str) {\n            var tagMatcher = /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)/i\n            var match = tagMatcher.exec( str );\n            if (match) {\n                return match[1].toLowerCase();\n            } else {\n                return \"\";\n            }\n        }\n\n        /**\n         *\n         * @param {string} resp\n         * @param {number} depth\n         * @returns {Element}\n         */\n        function parseHTML(resp, depth) {\n            var parser = new DOMParser();\n            var responseDoc = parser.parseFromString(resp, \"text/html\");\n\n            /** @type {Element} */\n            var responseNode = responseDoc.body;\n            while (depth > 0) {\n                depth--;\n                // @ts-ignore\n                responseNode = responseNode.firstChild;\n            }\n            if (responseNode == null) {\n                // @ts-ignore\n                responseNode = getDocument().createDocumentFragment();\n            }\n            return responseNode;\n        }\n\n        /**\n         *\n         * @param {string} resp\n         * @returns {Element}\n         */\n        function makeFragment(resp) {\n            if (htmx.config.useTemplateFragments) {\n                var documentFragment = parseHTML(\"<body><template>\" + resp + \"</template></body>\", 0);\n                // @ts-ignore type mismatch between DocumentFragment and Element.\n                // TODO: Are these close enough for htmx to use interchangably?\n                return documentFragment.querySelector('template').content;\n            } else {\n                var startTag = getStartTag(resp);\n                switch (startTag) {\n                    case \"thead\":\n                    case \"tbody\":\n                    case \"tfoot\":\n                    case \"colgroup\":\n                    case \"caption\":\n                        return parseHTML(\"<table>\" + resp + \"</table>\", 1);\n                    case \"col\":\n                        return parseHTML(\"<table><colgroup>\" + resp + \"</colgroup></table>\", 2);\n                    case \"tr\":\n                        return parseHTML(\"<table><tbody>\" + resp + \"</tbody></table>\", 2);\n                    case \"td\":\n                    case \"th\":\n                        return parseHTML(\"<table><tbody><tr>\" + resp + \"</tr></tbody></table>\", 3);\n                    case \"script\":\n                        return parseHTML(\"<div>\" + resp + \"</div>\", 1);\n                    default:\n                        return parseHTML(resp, 0);\n                }\n            }\n        }\n\n        /**\n         * @param {Function} func\n         */\n        function maybeCall(func){\n            if(func) {\n                func();\n            }\n        }\n\n        /**\n         * @param {any} o\n         * @param {string} type\n         * @returns\n         */\n        function isType(o, type) {\n            return Object.prototype.toString.call(o) === \"[object \" + type + \"]\";\n        }\n\n        /**\n         * @param {*} o\n         * @returns {o is Function}\n         */\n        function isFunction(o) {\n            return isType(o, \"Function\");\n        }\n\n        /**\n         * @param {*} o\n         * @returns {o is Object}\n         */\n        function isRawObject(o) {\n            return isType(o, \"Object\");\n        }\n\n        /**\n         * getInternalData retrieves \"private\" data stored by htmx within an element\n         * @param {HTMLElement} elt\n         * @returns {*}\n         */\n        function getInternalData(elt) {\n            var dataProp = 'htmx-internal-data';\n            var data = elt[dataProp];\n            if (!data) {\n                data = elt[dataProp] = {};\n            }\n            return data;\n        }\n\n        /**\n         * toArray converts an ArrayLike object into a real array.\n         * @param {ArrayLike} arr\n         * @returns {any[]}\n         */\n        function toArray(arr) {\n            var returnArr = [];\n            if (arr) {\n                for (var i = 0; i < arr.length; i++) {\n                    returnArr.push(arr[i]);\n                }\n            }\n            return returnArr\n        }\n\n        function forEach(arr, func) {\n            if (arr) {\n                for (var i = 0; i < arr.length; i++) {\n                    func(arr[i]);\n                }\n            }\n        }\n\n        function isScrolledIntoView(el) {\n            var rect = el.getBoundingClientRect();\n            var elemTop = rect.top;\n            var elemBottom = rect.bottom;\n            return elemTop < window.innerHeight && elemBottom >= 0;\n        }\n\n        function bodyContains(elt) {\n            // IE Fix\n            if (elt.getRootNode && elt.getRootNode() instanceof ShadowRoot) {\n                return getDocument().body.contains(elt.getRootNode().host);\n            } else {\n                return getDocument().body.contains(elt);\n            }\n        }\n\n        function splitOnWhitespace(trigger) {\n            return trigger.trim().split(/\\s+/);\n        }\n\n        /**\n         * mergeObjects takes all of the keys from\n         * obj2 and duplicates them into obj1\n         * @param {Object} obj1\n         * @param {Object} obj2\n         * @returns {Object}\n         */\n        function mergeObjects(obj1, obj2) {\n            for (var key in obj2) {\n                if (obj2.hasOwnProperty(key)) {\n                    obj1[key] = obj2[key];\n                }\n            }\n            return obj1;\n        }\n\n        function parseJSON(jString) {\n            try {\n                return JSON.parse(jString);\n            } catch(error) {\n                logError(error);\n                return null;\n            }\n        }\n\n        function canAccessLocalStorage() {\n            var test = 'htmx:localStorageTest';\n            try {\n                localStorage.setItem(test, test);\n                localStorage.removeItem(test);\n                return true;\n            } catch(e) {\n                return false;\n            }\n        }\n\n        //==========================================================================================\n        // public API\n        //==========================================================================================\n\n        function internalEval(str){\n            return maybeEval(getDocument().body, function () {\n                return eval(str);\n            });\n        }\n\n        function onLoadHelper(callback) {\n            var value = htmx.on(\"htmx:load\", function(evt) {\n                callback(evt.detail.elt);\n            });\n            return value;\n        }\n\n        function logAll(){\n            htmx.logger = function(elt, event, data) {\n                if(console) {\n                    console.log(event, elt, data);\n                }\n            }\n        }\n\n        function find(eltOrSelector, selector) {\n            if (selector) {\n                return eltOrSelector.querySelector(selector);\n            } else {\n                return find(getDocument(), eltOrSelector);\n            }\n        }\n\n        function findAll(eltOrSelector, selector) {\n            if (selector) {\n                return eltOrSelector.querySelectorAll(selector);\n            } else {\n                return findAll(getDocument(), eltOrSelector);\n            }\n        }\n\n        function removeElement(elt, delay) {\n            elt = resolveTarget(elt);\n            if (delay) {\n                setTimeout(function(){removeElement(elt);}, delay)\n            } else {\n                elt.parentElement.removeChild(elt);\n            }\n        }\n\n        function addClassToElement(elt, clazz, delay) {\n            elt = resolveTarget(elt);\n            if (delay) {\n                setTimeout(function(){addClassToElement(elt, clazz);}, delay)\n            } else {\n                elt.classList && elt.classList.add(clazz);\n            }\n        }\n\n        function removeClassFromElement(elt, clazz, delay) {\n            elt = resolveTarget(elt);\n            if (delay) {\n                setTimeout(function(){removeClassFromElement(elt, clazz);}, delay)\n            } else {\n                if (elt.classList) {\n                    elt.classList.remove(clazz);\n                    // if there are no classes left, remove the class attribute\n                    if (elt.classList.length === 0) {\n                        elt.removeAttribute(\"class\");\n                    }\n                }\n            }\n        }\n\n        function toggleClassOnElement(elt, clazz) {\n            elt = resolveTarget(elt);\n            elt.classList.toggle(clazz);\n        }\n\n        function takeClassForElement(elt, clazz) {\n            elt = resolveTarget(elt);\n            forEach(elt.parentElement.children, function(child){\n                removeClassFromElement(child, clazz);\n            })\n            addClassToElement(elt, clazz);\n        }\n\n        function closest(elt, selector) {\n            elt = resolveTarget(elt);\n            if (elt.closest) {\n                return elt.closest(selector);\n            } else {\n                // TODO remove when IE goes away\n                do{\n                    if (elt == null || matches(elt, selector)){\n                        return elt;\n                    }\n                }\n                while (elt = elt && parentElt(elt));\n                return null;\n            }\n        }\n\n        function querySelectorAllExt(elt, selector) {\n            if (selector.indexOf(\"closest \") === 0) {\n                return [closest(elt, selector.substr(8))];\n            } else if (selector.indexOf(\"find \") === 0) {\n                return [find(elt, selector.substr(5))];\n            } else if (selector.indexOf(\"next \") === 0) {\n                return [scanForwardQuery(elt, selector.substr(5))];\n            } else if (selector.indexOf(\"previous \") === 0) {\n                return [scanBackwardsQuery(elt, selector.substr(9))];\n            } else if (selector === 'document') {\n                return [document];\n            } else if (selector === 'window') {\n                return [window];\n            } else {\n                return getDocument().querySelectorAll(selector);\n            }\n        }\n\n        var scanForwardQuery = function(start, match) {\n            var results = getDocument().querySelectorAll(match);\n            for (var i = 0; i < results.length; i++) {\n                var elt = results[i];\n                if (elt.compareDocumentPosition(start) === Node.DOCUMENT_POSITION_PRECEDING) {\n                    return elt;\n                }\n            }\n        }\n\n        var scanBackwardsQuery = function(start, match) {\n            var results = getDocument().querySelectorAll(match);\n            for (var i = results.length - 1; i >= 0; i--) {\n                var elt = results[i];\n                if (elt.compareDocumentPosition(start) === Node.DOCUMENT_POSITION_FOLLOWING) {\n                    return elt;\n                }\n            }\n        }\n\n        function querySelectorExt(eltOrSelector, selector) {\n            if (selector) {\n                return querySelectorAllExt(eltOrSelector, selector)[0];\n            } else {\n                return querySelectorAllExt(getDocument().body, eltOrSelector)[0];\n            }\n        }\n\n        function resolveTarget(arg2) {\n            if (isType(arg2, 'String')) {\n                return find(arg2);\n            } else {\n                return arg2;\n            }\n        }\n\n        function processEventArgs(arg1, arg2, arg3) {\n            if (isFunction(arg2)) {\n                return {\n                    target: getDocument().body,\n                    event: arg1,\n                    listener: arg2\n                }\n            } else {\n                return {\n                    target: resolveTarget(arg1),\n                    event: arg2,\n                    listener: arg3\n                }\n            }\n\n        }\n\n        function addEventListenerImpl(arg1, arg2, arg3) {\n            ready(function(){\n                var eventArgs = processEventArgs(arg1, arg2, arg3);\n                eventArgs.target.addEventListener(eventArgs.event, eventArgs.listener);\n            })\n            var b = isFunction(arg2);\n            return b ? arg2 : arg3;\n        }\n\n        function removeEventListenerImpl(arg1, arg2, arg3) {\n            ready(function(){\n                var eventArgs = processEventArgs(arg1, arg2, arg3);\n                eventArgs.target.removeEventListener(eventArgs.event, eventArgs.listener);\n            })\n            return isFunction(arg2) ? arg2 : arg3;\n        }\n\n        //====================================================================\n        // Node processing\n        //====================================================================\n\n        var DUMMY_ELT = getDocument().createElement(\"output\"); // dummy element for bad selectors\n        function findAttributeTargets(elt, attrName) {\n            var attrTarget = getClosestAttributeValue(elt, attrName);\n            if (attrTarget) {\n                if (attrTarget === \"this\") {\n                    return [findThisElement(elt, attrName)];\n                } else {\n                    var result = querySelectorAllExt(elt, attrTarget);\n                    if (result.length === 0) {\n                        logError('The selector \"' + attrTarget + '\" on ' + attrName + \" returned no matches!\");\n                        return [DUMMY_ELT]\n                    } else {\n                        return result;\n                    }\n                }\n            }\n        }\n\n        function findThisElement(elt, attribute){\n            return getClosestMatch(elt, function (elt) {\n                return getAttributeValue(elt, attribute) != null;\n            })\n        }\n\n        function getTarget(elt) {\n            var targetStr = getClosestAttributeValue(elt, \"hx-target\");\n            if (targetStr) {\n                if (targetStr === \"this\") {\n                    return findThisElement(elt,'hx-target');\n                } else {\n                    return querySelectorExt(elt, targetStr)\n                }\n            } else {\n                var data = getInternalData(elt);\n                if (data.boosted) {\n                    return getDocument().body;\n                } else {\n                    return elt;\n                }\n            }\n        }\n\n        function shouldSettleAttribute(name) {\n            var attributesToSettle = htmx.config.attributesToSettle;\n            for (var i = 0; i < attributesToSettle.length; i++) {\n                if (name === attributesToSettle[i]) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        function cloneAttributes(mergeTo, mergeFrom) {\n            forEach(mergeTo.attributes, function (attr) {\n                if (!mergeFrom.hasAttribute(attr.name) && shouldSettleAttribute(attr.name)) {\n                    mergeTo.removeAttribute(attr.name)\n                }\n            });\n            forEach(mergeFrom.attributes, function (attr) {\n                if (shouldSettleAttribute(attr.name)) {\n                    mergeTo.setAttribute(attr.name, attr.value);\n                }\n            });\n        }\n\n        function isInlineSwap(swapStyle, target) {\n            var extensions = getExtensions(target);\n            for (var i = 0; i < extensions.length; i++) {\n                var extension = extensions[i];\n                try {\n                    if (extension.isInlineSwap(swapStyle)) {\n                        return true;\n                    }\n                } catch(e) {\n                    logError(e);\n                }\n            }\n            return swapStyle === \"outerHTML\";\n        }\n\n        /**\n         *\n         * @param {string} oobValue\n         * @param {HTMLElement} oobElement\n         * @param {*} settleInfo\n         * @returns\n         */\n        function oobSwap(oobValue, oobElement, settleInfo) {\n            var selector = \"#\" + oobElement.id;\n            var swapStyle = \"outerHTML\";\n            if (oobValue === \"true\") {\n                // do nothing\n            } else if (oobValue.indexOf(\":\") > 0) {\n                swapStyle = oobValue.substr(0, oobValue.indexOf(\":\"));\n                selector  = oobValue.substr(oobValue.indexOf(\":\") + 1, oobValue.length);\n            } else {\n                swapStyle = oobValue;\n            }\n\n            var targets = getDocument().querySelectorAll(selector);\n            if (targets) {\n                forEach(\n                    targets,\n                    function (target) {\n                        var fragment;\n                        var oobElementClone = oobElement.cloneNode(true);\n                        fragment = getDocument().createDocumentFragment();\n                        fragment.appendChild(oobElementClone);\n                        if (!isInlineSwap(swapStyle, target)) {\n                            fragment = oobElementClone; // if this is not an inline swap, we use the content of the node, not the node itself\n                        }\n\n                        var beforeSwapDetails = {shouldSwap: true, target: target, fragment:fragment };\n                        if (!triggerEvent(target, 'htmx:oobBeforeSwap', beforeSwapDetails)) return;\n\n                        target = beforeSwapDetails.target; // allow re-targeting\n                        if (beforeSwapDetails['shouldSwap']){\n                            swap(swapStyle, target, target, fragment, settleInfo);\n                        }\n                        forEach(settleInfo.elts, function (elt) {\n                            triggerEvent(elt, 'htmx:oobAfterSwap', beforeSwapDetails);\n                        });\n                    }\n                );\n                oobElement.parentNode.removeChild(oobElement);\n            } else {\n                oobElement.parentNode.removeChild(oobElement);\n                triggerErrorEvent(getDocument().body, \"htmx:oobErrorNoTarget\", {content: oobElement});\n            }\n            return oobValue;\n        }\n\n        function handleOutOfBandSwaps(elt, fragment, settleInfo) {\n            var oobSelects = getClosestAttributeValue(elt, \"hx-select-oob\");\n            if (oobSelects) {\n                var oobSelectValues = oobSelects.split(\",\");\n                for (let i = 0; i < oobSelectValues.length; i++) {\n                    var oobSelectValue = oobSelectValues[i].split(\":\", 2);\n                    var id = oobSelectValue[0];\n                    if (id.indexOf(\"#\") === 0) {\n                        id = id.substring(1);\n                    }\n                    var oobValue = oobSelectValue[1] || \"true\";\n                    var oobElement = fragment.querySelector(\"#\" + id);\n                    if (oobElement) {\n                        oobSwap(oobValue, oobElement, settleInfo);\n                    }\n                }\n            }\n            forEach(findAll(fragment, '[hx-swap-oob], [data-hx-swap-oob]'), function (oobElement) {\n                var oobValue = getAttributeValue(oobElement, \"hx-swap-oob\");\n                if (oobValue != null) {\n                    oobSwap(oobValue, oobElement, settleInfo);\n                }\n            });\n        }\n\n        function handlePreservedElements(fragment) {\n            forEach(findAll(fragment, '[hx-preserve], [data-hx-preserve]'), function (preservedElt) {\n                var id = getAttributeValue(preservedElt, \"id\");\n                var oldElt = getDocument().getElementById(id);\n                if (oldElt != null) {\n                    preservedElt.parentNode.replaceChild(oldElt, preservedElt);\n                }\n            });\n        }\n\n        function handleAttributes(parentNode, fragment, settleInfo) {\n            forEach(fragment.querySelectorAll(\"[id]\"), function (newNode) {\n                if (newNode.id && newNode.id.length > 0) {\n                    var normalizedId = newNode.id.replace(\"'\", \"\\\\'\");\n                    var oldNode = parentNode.querySelector(newNode.tagName + \"[id='\" + normalizedId + \"']\");\n                    if (oldNode && oldNode !== parentNode) {\n                        var newAttributes = newNode.cloneNode();\n                        cloneAttributes(newNode, oldNode);\n                        settleInfo.tasks.push(function () {\n                            cloneAttributes(newNode, newAttributes);\n                        });\n                    }\n                }\n            });\n        }\n\n        function makeAjaxLoadTask(child) {\n            return function () {\n                removeClassFromElement(child, htmx.config.addedClass);\n                processNode(child);\n                processScripts(child);\n                processFocus(child)\n                triggerEvent(child, 'htmx:load');\n            };\n        }\n\n        function processFocus(child) {\n            var autofocus = \"[autofocus]\";\n            var autoFocusedElt = matches(child, autofocus) ? child : child.querySelector(autofocus)\n            if (autoFocusedElt != null) {\n                autoFocusedElt.focus();\n            }\n        }\n\n        function insertNodesBefore(parentNode, insertBefore, fragment, settleInfo) {\n            handleAttributes(parentNode, fragment, settleInfo);\n            while(fragment.childNodes.length > 0){\n                var child = fragment.firstChild;\n                addClassToElement(child, htmx.config.addedClass);\n                parentNode.insertBefore(child, insertBefore);\n                if (child.nodeType !== Node.TEXT_NODE && child.nodeType !== Node.COMMENT_NODE) {\n                    settleInfo.tasks.push(makeAjaxLoadTask(child));\n                }\n            }\n        }\n\n        // based on https://gist.github.com/hyamamoto/fd435505d29ebfa3d9716fd2be8d42f0,\n        // derived from Java's string hashcode implementation\n        function stringHash(string, hash) {\n            var char = 0;\n            while (char < string.length){\n                hash = (hash << 5) - hash + string.charCodeAt(char++) | 0; // bitwise or ensures we have a 32-bit int\n            }\n            return hash;\n        }\n\n        function attributeHash(elt) {\n            var hash = 0;\n            // IE fix\n            if (elt.attributes) {\n                for (var i = 0; i < elt.attributes.length; i++) {\n                    var attribute = elt.attributes[i];\n                    if(attribute.value){ // only include attributes w/ actual values (empty is same as non-existent)\n                        hash = stringHash(attribute.name, hash);\n                        hash = stringHash(attribute.value, hash);\n                    }\n                }\n            }\n            return hash;\n        }\n\n        function deInitNode(element) {\n            var internalData = getInternalData(element);\n            if (internalData.webSocket) {\n                internalData.webSocket.close();\n            }\n            if (internalData.sseEventSource) {\n                internalData.sseEventSource.close();\n            }\n            if (internalData.listenerInfos) {\n                forEach(internalData.listenerInfos, function (info) {\n                    if (info.on) {\n                        info.on.removeEventListener(info.trigger, info.listener);\n                    }\n                });\n            }\n        }\n\n        function cleanUpElement(element) {\n            triggerEvent(element, \"htmx:beforeCleanupElement\")\n            deInitNode(element);\n            if (element.children) { // IE\n                forEach(element.children, function(child) { cleanUpElement(child) });\n            }\n        }\n\n        function swapOuterHTML(target, fragment, settleInfo) {\n            if (target.tagName === \"BODY\") {\n                return swapInnerHTML(target, fragment, settleInfo);\n            } else {\n                // @type {HTMLElement}\n                var newElt\n                var eltBeforeNewContent = target.previousSibling;\n                insertNodesBefore(parentElt(target), target, fragment, settleInfo);\n                if (eltBeforeNewContent == null) {\n                    newElt = parentElt(target).firstChild;\n                } else {\n                    newElt = eltBeforeNewContent.nextSibling;\n                }\n                getInternalData(target).replacedWith = newElt; // tuck away so we can fire events on it later\n                settleInfo.elts = [] // clear existing elements\n                while(newElt && newElt !== target) {\n                    if (newElt.nodeType === Node.ELEMENT_NODE) {\n                        settleInfo.elts.push(newElt);\n                    }\n                    newElt = newElt.nextElementSibling;\n                }\n                cleanUpElement(target);\n                parentElt(target).removeChild(target);\n            }\n        }\n\n        function swapAfterBegin(target, fragment, settleInfo) {\n            return insertNodesBefore(target, target.firstChild, fragment, settleInfo);\n        }\n\n        function swapBeforeBegin(target, fragment, settleInfo) {\n            return insertNodesBefore(parentElt(target), target, fragment, settleInfo);\n        }\n\n        function swapBeforeEnd(target, fragment, settleInfo) {\n            return insertNodesBefore(target, null, fragment, settleInfo);\n        }\n\n        function swapAfterEnd(target, fragment, settleInfo) {\n            return insertNodesBefore(parentElt(target), target.nextSibling, fragment, settleInfo);\n        }\n        function swapDelete(target, fragment, settleInfo) {\n            cleanUpElement(target);\n            return parentElt(target).removeChild(target);\n        }\n\n        function swapInnerHTML(target, fragment, settleInfo) {\n            var firstChild = target.firstChild;\n            insertNodesBefore(target, firstChild, fragment, settleInfo);\n            if (firstChild) {\n                while (firstChild.nextSibling) {\n                    cleanUpElement(firstChild.nextSibling)\n                    target.removeChild(firstChild.nextSibling);\n                }\n                cleanUpElement(firstChild)\n                target.removeChild(firstChild);\n            }\n        }\n\n        function maybeSelectFromResponse(elt, fragment) {\n            var selector = getClosestAttributeValue(elt, \"hx-select\");\n            if (selector) {\n                var newFragment = getDocument().createDocumentFragment();\n                forEach(fragment.querySelectorAll(selector), function (node) {\n                    newFragment.appendChild(node);\n                });\n                fragment = newFragment;\n            }\n            return fragment;\n        }\n\n        function swap(swapStyle, elt, target, fragment, settleInfo) {\n            switch (swapStyle) {\n                case \"none\":\n                    return;\n                case \"outerHTML\":\n                    swapOuterHTML(target, fragment, settleInfo);\n                    return;\n                case \"afterbegin\":\n                    swapAfterBegin(target, fragment, settleInfo);\n                    return;\n                case \"beforebegin\":\n                    swapBeforeBegin(target, fragment, settleInfo);\n                    return;\n                case \"beforeend\":\n                    swapBeforeEnd(target, fragment, settleInfo);\n                    return;\n                case \"afterend\":\n                    swapAfterEnd(target, fragment, settleInfo);\n                    return;\n                case \"delete\":\n                    swapDelete(target, fragment, settleInfo);\n                    return;\n                default:\n                    var extensions = getExtensions(elt);\n                    for (var i = 0; i < extensions.length; i++) {\n                        var ext = extensions[i];\n                        try {\n                            var newElements = ext.handleSwap(swapStyle, target, fragment, settleInfo);\n                            if (newElements) {\n                                if (typeof newElements.length !== 'undefined') {\n                                    // if handleSwap returns an array (like) of elements, we handle them\n                                    for (var j = 0; j < newElements.length; j++) {\n                                        var child = newElements[j];\n                                        if (child.nodeType !== Node.TEXT_NODE && child.nodeType !== Node.COMMENT_NODE) {\n                                            settleInfo.tasks.push(makeAjaxLoadTask(child));\n                                        }\n                                    }\n                                }\n                                return;\n                            }\n                        } catch (e) {\n                            logError(e);\n                        }\n                    }\n                    if (swapStyle === \"innerHTML\") {\n                        swapInnerHTML(target, fragment, settleInfo);\n                    } else {\n                        swap(htmx.config.defaultSwapStyle, elt, target, fragment, settleInfo);\n                    }\n            }\n        }\n\n        function findTitle(content) {\n            if (content.indexOf('<title') > -1) {\n                var contentWithSvgsRemoved = content.replace(/<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim, '');\n                var result = contentWithSvgsRemoved.match(/<title(\\s[^>]*>|>)([\\s\\S]*?)<\\/title>/im);\n\n                if (result) {\n                    return result[2];\n                }\n            }\n        }\n\n        function selectAndSwap(swapStyle, target, elt, responseText, settleInfo) {\n            settleInfo.title = findTitle(responseText);\n            var fragment = makeFragment(responseText);\n            if (fragment) {\n                handleOutOfBandSwaps(elt, fragment, settleInfo);\n                fragment = maybeSelectFromResponse(elt, fragment);\n                handlePreservedElements(fragment);\n                return swap(swapStyle, elt, target, fragment, settleInfo);\n            }\n        }\n\n        function handleTrigger(xhr, header, elt) {\n            var triggerBody = xhr.getResponseHeader(header);\n            if (triggerBody.indexOf(\"{\") === 0) {\n                var triggers = parseJSON(triggerBody);\n                for (var eventName in triggers) {\n                    if (triggers.hasOwnProperty(eventName)) {\n                        var detail = triggers[eventName];\n                        if (!isRawObject(detail)) {\n                            detail = {\"value\": detail}\n                        }\n                        triggerEvent(elt, eventName, detail);\n                    }\n                }\n            } else {\n                triggerEvent(elt, triggerBody, []);\n            }\n        }\n\n        var WHITESPACE = /\\s/;\n        var WHITESPACE_OR_COMMA = /[\\s,]/;\n        var SYMBOL_START = /[_$a-zA-Z]/;\n        var SYMBOL_CONT = /[_$a-zA-Z0-9]/;\n        var STRINGISH_START = ['\"', \"'\", \"/\"];\n        var NOT_WHITESPACE = /[^\\s]/;\n        function tokenizeString(str) {\n            var tokens = [];\n            var position = 0;\n            while (position < str.length) {\n                if(SYMBOL_START.exec(str.charAt(position))) {\n                    var startPosition = position;\n                    while (SYMBOL_CONT.exec(str.charAt(position + 1))) {\n                        position++;\n                    }\n                    tokens.push(str.substr(startPosition, position - startPosition + 1));\n                } else if (STRINGISH_START.indexOf(str.charAt(position)) !== -1) {\n                    var startChar = str.charAt(position);\n                    var startPosition = position;\n                    position++;\n                    while (position < str.length && str.charAt(position) !== startChar ) {\n                        if (str.charAt(position) === \"\\\\\") {\n                            position++;\n                        }\n                        position++;\n                    }\n                    tokens.push(str.substr(startPosition, position - startPosition + 1));\n                } else {\n                    var symbol = str.charAt(position);\n                    tokens.push(symbol);\n                }\n                position++;\n            }\n            return tokens;\n        }\n\n        function isPossibleRelativeReference(token, last, paramName) {\n            return SYMBOL_START.exec(token.charAt(0)) &&\n                token !== \"true\" &&\n                token !== \"false\" &&\n                token !== \"this\" &&\n                token !== paramName &&\n                last !== \".\";\n        }\n\n        function maybeGenerateConditional(elt, tokens, paramName) {\n            if (tokens[0] === '[') {\n                tokens.shift();\n                var bracketCount = 1;\n                var conditionalSource = \" return (function(\" + paramName + \"){ return (\";\n                var last = null;\n                while (tokens.length > 0) {\n                    var token = tokens[0];\n                    if (token === \"]\") {\n                        bracketCount--;\n                        if (bracketCount === 0) {\n                            if (last === null) {\n                                conditionalSource = conditionalSource + \"true\";\n                            }\n                            tokens.shift();\n                            conditionalSource += \")})\";\n                            try {\n                                var conditionFunction = maybeEval(elt,function () {\n                                    return Function(conditionalSource)();\n                                    },\n                                    function(){return true})\n                                conditionFunction.source = conditionalSource;\n                                return conditionFunction;\n                            } catch (e) {\n                                triggerErrorEvent(getDocument().body, \"htmx:syntax:error\", {error:e, source:conditionalSource})\n                                return null;\n                            }\n                        }\n                    } else if (token === \"[\") {\n                        bracketCount++;\n                    }\n                    if (isPossibleRelativeReference(token, last, paramName)) {\n                            conditionalSource += \"((\" + paramName + \".\" + token + \") ? (\" + paramName + \".\" + token + \") : (window.\" + token + \"))\";\n                    } else {\n                        conditionalSource = conditionalSource + token;\n                    }\n                    last = tokens.shift();\n                }\n            }\n        }\n\n        function consumeUntil(tokens, match) {\n            var result = \"\";\n            while (tokens.length > 0 && !tokens[0].match(match)) {\n                result += tokens.shift();\n            }\n            return result;\n        }\n\n        var INPUT_SELECTOR = 'input, textarea, select';\n\n        /**\n         * @param {HTMLElement} elt\n         * @returns {import(\"./htmx\").HtmxTriggerSpecification[]}\n         */\n        function getTriggerSpecs(elt) {\n            var explicitTrigger = getAttributeValue(elt, 'hx-trigger');\n            var triggerSpecs = [];\n            if (explicitTrigger) {\n                var tokens = tokenizeString(explicitTrigger);\n                do {\n                    consumeUntil(tokens, NOT_WHITESPACE);\n                    var initialLength = tokens.length;\n                    var trigger = consumeUntil(tokens, /[,\\[\\s]/);\n                    if (trigger !== \"\") {\n                        if (trigger === \"every\") {\n                            var every = {trigger: 'every'};\n                            consumeUntil(tokens, NOT_WHITESPACE);\n                            every.pollInterval = parseInterval(consumeUntil(tokens, /[,\\[\\s]/));\n                            consumeUntil(tokens, NOT_WHITESPACE);\n                            var eventFilter = maybeGenerateConditional(elt, tokens, \"event\");\n                            if (eventFilter) {\n                                every.eventFilter = eventFilter;\n                            }\n                            triggerSpecs.push(every);\n                        } else if (trigger.indexOf(\"sse:\") === 0) {\n                            triggerSpecs.push({trigger: 'sse', sseEvent: trigger.substr(4)});\n                        } else {\n                            var triggerSpec = {trigger: trigger};\n                            var eventFilter = maybeGenerateConditional(elt, tokens, \"event\");\n                            if (eventFilter) {\n                                triggerSpec.eventFilter = eventFilter;\n                            }\n                            while (tokens.length > 0 && tokens[0] !== \",\") {\n                                consumeUntil(tokens, NOT_WHITESPACE)\n                                var token = tokens.shift();\n                                if (token === \"changed\") {\n                                    triggerSpec.changed = true;\n                                } else if (token === \"once\") {\n                                    triggerSpec.once = true;\n                                } else if (token === \"consume\") {\n                                    triggerSpec.consume = true;\n                                } else if (token === \"delay\" && tokens[0] === \":\") {\n                                    tokens.shift();\n                                    triggerSpec.delay = parseInterval(consumeUntil(tokens, WHITESPACE_OR_COMMA));\n                                } else if (token === \"from\" && tokens[0] === \":\") {\n                                    tokens.shift();\n                                    var from_arg = consumeUntil(tokens, WHITESPACE_OR_COMMA);\n                                    if (from_arg === \"closest\" || from_arg === \"find\" || from_arg === \"next\" || from_arg === \"previous\") {\n                                        tokens.shift();\n                                        from_arg +=\n                                            \" \" +\n                                            consumeUntil(\n                                                tokens,\n                                                WHITESPACE_OR_COMMA\n                                            );\n                                    }\n                                    triggerSpec.from = from_arg;\n                                } else if (token === \"target\" && tokens[0] === \":\") {\n                                    tokens.shift();\n                                    triggerSpec.target = consumeUntil(tokens, WHITESPACE_OR_COMMA);\n                                } else if (token === \"throttle\" && tokens[0] === \":\") {\n                                    tokens.shift();\n                                    triggerSpec.throttle = parseInterval(consumeUntil(tokens, WHITESPACE_OR_COMMA));\n                                } else if (token === \"queue\" && tokens[0] === \":\") {\n                                    tokens.shift();\n                                    triggerSpec.queue = consumeUntil(tokens, WHITESPACE_OR_COMMA);\n                                } else if ((token === \"root\" || token === \"threshold\") && tokens[0] === \":\") {\n                                    tokens.shift();\n                                    triggerSpec[token] = consumeUntil(tokens, WHITESPACE_OR_COMMA);\n                                } else {\n                                    triggerErrorEvent(elt, \"htmx:syntax:error\", {token:tokens.shift()});\n                                }\n                            }\n                            triggerSpecs.push(triggerSpec);\n                        }\n                    }\n                    if (tokens.length === initialLength) {\n                        triggerErrorEvent(elt, \"htmx:syntax:error\", {token:tokens.shift()});\n                    }\n                    consumeUntil(tokens, NOT_WHITESPACE);\n                } while (tokens[0] === \",\" && tokens.shift())\n            }\n\n            if (triggerSpecs.length > 0) {\n                return triggerSpecs;\n            } else if (matches(elt, 'form')) {\n                return [{trigger: 'submit'}];\n            } else if (matches(elt, 'input[type=\"button\"]')){\n                return [{trigger: 'click'}];\n            } else if (matches(elt, INPUT_SELECTOR)) {\n                return [{trigger: 'change'}];\n            } else {\n                return [{trigger: 'click'}];\n            }\n        }\n\n        function cancelPolling(elt) {\n            getInternalData(elt).cancelled = true;\n        }\n\n        function processPolling(elt, handler, spec) {\n            var nodeData = getInternalData(elt);\n            nodeData.timeout = setTimeout(function () {\n                if (bodyContains(elt) && nodeData.cancelled !== true) {\n                    if (!maybeFilterEvent(spec, makeEvent('hx:poll:trigger', {triggerSpec:spec, target:elt}))) {\n                        handler(elt);\n                    }\n                    processPolling(elt, handler, spec);\n                }\n            }, spec.pollInterval);\n        }\n\n        function isLocalLink(elt) {\n            return location.hostname === elt.hostname &&\n                getRawAttribute(elt,'href') &&\n                getRawAttribute(elt,'href').indexOf(\"#\") !== 0;\n        }\n\n        function boostElement(elt, nodeData, triggerSpecs) {\n            if ((elt.tagName === \"A\" && isLocalLink(elt) && (elt.target === \"\" || elt.target === \"_self\")) || elt.tagName === \"FORM\") {\n                nodeData.boosted = true;\n                var verb, path;\n                if (elt.tagName === \"A\") {\n                    verb = \"get\";\n                    path = getRawAttribute(elt, 'href');\n                } else {\n                    var rawAttribute = getRawAttribute(elt, \"method\");\n                    verb = rawAttribute ? rawAttribute.toLowerCase() : \"get\";\n                    if (verb === \"get\") {\n                    }\n                    path = getRawAttribute(elt, 'action');\n                }\n                triggerSpecs.forEach(function(triggerSpec) {\n                    addEventListener(elt, function(elt, evt) {\n                        issueAjaxRequest(verb, path, elt, evt)\n                    }, nodeData, triggerSpec, true);\n                });\n            }\n        }\n\n        /**\n         *\n         * @param {Event} evt\n         * @param {HTMLElement} elt\n         * @returns\n         */\n        function shouldCancel(evt, elt) {\n            if (evt.type === \"submit\" || evt.type === \"click\") {\n                if (elt.tagName === \"FORM\") {\n                    return true;\n                }\n                if (matches(elt, 'input[type=\"submit\"], button') && closest(elt, 'form') !== null) {\n                    return true;\n                }\n                if (elt.tagName === \"A\" && elt.href &&\n                    (elt.getAttribute('href') === '#' || elt.getAttribute('href').indexOf(\"#\") !== 0)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        function ignoreBoostedAnchorCtrlClick(elt, evt) {\n            return getInternalData(elt).boosted && elt.tagName === \"A\" && evt.type === \"click\" && (evt.ctrlKey || evt.metaKey);\n        }\n\n        function maybeFilterEvent(triggerSpec, evt) {\n            var eventFilter = triggerSpec.eventFilter;\n            if(eventFilter){\n                try {\n                    return eventFilter(evt) !== true;\n                } catch(e) {\n                    triggerErrorEvent(getDocument().body, \"htmx:eventFilter:error\", {error: e, source:eventFilter.source});\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        function addEventListener(elt, handler, nodeData, triggerSpec, explicitCancel) {\n            var elementData = getInternalData(elt);\n            var eltsToListenOn;\n            if (triggerSpec.from) {\n                eltsToListenOn = querySelectorAllExt(elt, triggerSpec.from);\n            } else {\n                eltsToListenOn = [elt];\n            }\n            // store the initial value of the element so we can tell if it changes\n            if (triggerSpec.changed) {\n                elementData.lastValue = elt.value;\n            }\n            forEach(eltsToListenOn, function (eltToListenOn) {\n                var eventListener = function (evt) {\n                    if (!bodyContains(elt)) {\n                        eltToListenOn.removeEventListener(triggerSpec.trigger, eventListener);\n                        return;\n                    }\n                    if (ignoreBoostedAnchorCtrlClick(elt, evt)) {\n                        return;\n                    }\n                    if (explicitCancel || shouldCancel(evt, elt)) {\n                        evt.preventDefault();\n                    }\n                    if (maybeFilterEvent(triggerSpec, evt)) {\n                        return;\n                    }\n                    var eventData = getInternalData(evt);\n                    eventData.triggerSpec = triggerSpec;\n                    if (eventData.handledFor == null) {\n                        eventData.handledFor = [];\n                    }\n                    if (eventData.handledFor.indexOf(elt) < 0) {\n                        eventData.handledFor.push(elt);\n                        if (triggerSpec.consume) {\n                            evt.stopPropagation();\n                        }\n                        if (triggerSpec.target && evt.target) {\n                            if (!matches(evt.target, triggerSpec.target)) {\n                                return;\n                            }\n                        }\n                        if (triggerSpec.once) {\n                            if (elementData.triggeredOnce) {\n                                return;\n                            } else {\n                                elementData.triggeredOnce = true;\n                            }\n                        }\n                        if (triggerSpec.changed) {\n                            if (elementData.lastValue === elt.value) {\n                                return;\n                            } else {\n                                elementData.lastValue = elt.value;\n                            }\n                        }\n                        if (elementData.delayed) {\n                            clearTimeout(elementData.delayed);\n                        }\n                        if (elementData.throttle) {\n                            return;\n                        }\n\n                        if (triggerSpec.throttle) {\n                            if (!elementData.throttle) {\n                                handler(elt, evt);\n                                elementData.throttle = setTimeout(function () {\n                                    elementData.throttle = null;\n                                }, triggerSpec.throttle);\n                            }\n                        } else if (triggerSpec.delay) {\n                            elementData.delayed = setTimeout(function() { handler(elt, evt) }, triggerSpec.delay);\n                        } else {\n                            handler(elt, evt);\n                        }\n                    }\n                };\n                if (nodeData.listenerInfos == null) {\n                    nodeData.listenerInfos = [];\n                }\n                nodeData.listenerInfos.push({\n                    trigger: triggerSpec.trigger,\n                    listener: eventListener,\n                    on: eltToListenOn\n                })\n                eltToListenOn.addEventListener(triggerSpec.trigger, eventListener);\n            });\n        }\n\n        var windowIsScrolling = false // used by initScrollHandler\n        var scrollHandler = null;\n        function initScrollHandler() {\n            if (!scrollHandler) {\n                scrollHandler = function() {\n                    windowIsScrolling = true\n                };\n                window.addEventListener(\"scroll\", scrollHandler)\n                setInterval(function() {\n                    if (windowIsScrolling) {\n                        windowIsScrolling = false;\n                        forEach(getDocument().querySelectorAll(\"[hx-trigger='revealed'],[data-hx-trigger='revealed']\"), function (elt) {\n                            maybeReveal(elt);\n                        })\n                    }\n                }, 200);\n            }\n        }\n\n        function maybeReveal(elt) {\n            if (!hasAttribute(elt,'data-hx-revealed') && isScrolledIntoView(elt)) {\n                elt.setAttribute('data-hx-revealed', 'true');\n                var nodeData = getInternalData(elt);\n                if (nodeData.initHash) {\n                    triggerEvent(elt, 'revealed');\n                } else {\n                    // if the node isn't initialized, wait for it before triggering the request\n                    elt.addEventListener(\"htmx:afterProcessNode\", function(evt) { triggerEvent(elt, 'revealed') }, {once: true});\n                }\n            }\n        }\n\n        //====================================================================\n        // Web Sockets\n        //====================================================================\n\n        function processWebSocketInfo(elt, nodeData, info) {\n            var values = splitOnWhitespace(info);\n            for (var i = 0; i < values.length; i++) {\n                var value = values[i].split(/:(.+)/);\n                if (value[0] === \"connect\") {\n                    ensureWebSocket(elt, value[1], 0);\n                }\n                if (value[0] === \"send\") {\n                    processWebSocketSend(elt);\n                }\n            }\n        }\n\n        function ensureWebSocket(elt, wssSource, retryCount) {\n            if (!bodyContains(elt)) {\n                return;  // stop ensuring websocket connection when socket bearing element ceases to exist\n            }\n\n            if (wssSource.indexOf(\"/\") == 0) {  // complete absolute paths only\n                var base_part = location.hostname + (location.port ? ':'+location.port: '');\n                if (location.protocol == 'https:') {\n                    wssSource = \"wss://\" + base_part + wssSource;\n                } else if (location.protocol == 'http:') {\n                    wssSource = \"ws://\" + base_part + wssSource;\n                }\n            }\n            var socket = htmx.createWebSocket(wssSource);\n            socket.onerror = function (e) {\n                triggerErrorEvent(elt, \"htmx:wsError\", {error:e, socket:socket});\n                maybeCloseWebSocketSource(elt);\n            };\n\n            socket.onclose = function (e) {\n                if ([1006, 1012, 1013].indexOf(e.code) >= 0) {  // Abnormal Closure/Service Restart/Try Again Later\n                    var delay = getWebSocketReconnectDelay(retryCount);\n                    setTimeout(function() {\n                        ensureWebSocket(elt, wssSource, retryCount+1);  // creates a websocket with a new timeout\n                    }, delay);\n                }\n            };\n            socket.onopen = function (e) {\n                retryCount = 0;\n            }\n\n            getInternalData(elt).webSocket = socket;\n            socket.addEventListener('message', function (event) {\n                if (maybeCloseWebSocketSource(elt)) {\n                    return;\n                }\n\n                var response = event.data;\n                withExtensions(elt, function(extension){\n                    response = extension.transformResponse(response, null, elt);\n                });\n\n                var settleInfo = makeSettleInfo(elt);\n                var fragment = makeFragment(response);\n                var children = toArray(fragment.children);\n                for (var i = 0; i < children.length; i++) {\n                    var child = children[i];\n                    oobSwap(getAttributeValue(child, \"hx-swap-oob\") || \"true\", child, settleInfo);\n                }\n\n                settleImmediately(settleInfo.tasks);\n            });\n        }\n\n        function maybeCloseWebSocketSource(elt) {\n            if (!bodyContains(elt)) {\n                getInternalData(elt).webSocket.close();\n                return true;\n            }\n        }\n\n        function processWebSocketSend(elt) {\n            var webSocketSourceElt = getClosestMatch(elt, function (parent) {\n                return getInternalData(parent).webSocket != null;\n            });\n            if (webSocketSourceElt) {\n                elt.addEventListener(getTriggerSpecs(elt)[0].trigger, function (evt) {\n                    var webSocket = getInternalData(webSocketSourceElt).webSocket;\n                    var headers = getHeaders(elt, webSocketSourceElt);\n                    var results = getInputValues(elt, 'post');\n                    var errors = results.errors;\n                    var rawParameters = results.values;\n                    var expressionVars = getExpressionVars(elt);\n                    var allParameters = mergeObjects(rawParameters, expressionVars);\n                    var filteredParameters = filterValues(allParameters, elt);\n                    filteredParameters['HEADERS'] = headers;\n                    if (errors && errors.length > 0) {\n                        triggerEvent(elt, 'htmx:validation:halted', errors);\n                        return;\n                    }\n                    webSocket.send(JSON.stringify(filteredParameters));\n                    if(shouldCancel(evt, elt)){\n                        evt.preventDefault();\n                    }\n                });\n            } else {\n                triggerErrorEvent(elt, \"htmx:noWebSocketSourceError\");\n            }\n        }\n\n        function getWebSocketReconnectDelay(retryCount) {\n            var delay = htmx.config.wsReconnectDelay;\n            if (typeof delay === 'function') {\n                // @ts-ignore\n                return delay(retryCount);\n            }\n            if (delay === 'full-jitter') {\n                var exp = Math.min(retryCount, 6);\n                var maxDelay = 1000 * Math.pow(2, exp);\n                return maxDelay * Math.random();\n            }\n            logError('htmx.config.wsReconnectDelay must either be a function or the string \"full-jitter\"');\n        }\n\n        //====================================================================\n        // Server Sent Events\n        //====================================================================\n\n        function processSSEInfo(elt, nodeData, info) {\n            var values = splitOnWhitespace(info);\n            for (var i = 0; i < values.length; i++) {\n                var value = values[i].split(/:(.+)/);\n                if (value[0] === \"connect\") {\n                    processSSESource(elt, value[1]);\n                }\n\n                if ((value[0] === \"swap\")) {\n                    processSSESwap(elt, value[1])\n                }\n            }\n        }\n\n        function processSSESource(elt, sseSrc) {\n            var source = htmx.createEventSource(sseSrc);\n            source.onerror = function (e) {\n                triggerErrorEvent(elt, \"htmx:sseError\", {error:e, source:source});\n                maybeCloseSSESource(elt);\n            };\n            getInternalData(elt).sseEventSource = source;\n        }\n\n        function processSSESwap(elt, sseEventName) {\n            var sseSourceElt = getClosestMatch(elt, hasEventSource);\n            if (sseSourceElt) {\n                var sseEventSource = getInternalData(sseSourceElt).sseEventSource;\n                var sseListener = function (event) {\n                    if (maybeCloseSSESource(sseSourceElt)) {\n                        sseEventSource.removeEventListener(sseEventName, sseListener);\n                        return;\n                    }\n\n                    ///////////////////////////\n                    // TODO: merge this code with AJAX and WebSockets code in the future.\n\n                    var response = event.data;\n                    withExtensions(elt, function(extension){\n                        response = extension.transformResponse(response, null, elt);\n                    });\n\n                    var swapSpec = getSwapSpecification(elt)\n                    var target = getTarget(elt)\n                    var settleInfo = makeSettleInfo(elt);\n\n                    selectAndSwap(swapSpec.swapStyle, elt, target, response, settleInfo)\n                    settleImmediately(settleInfo.tasks)\n                    triggerEvent(elt, \"htmx:sseMessage\", event)\n                };\n\n                getInternalData(elt).sseListener = sseListener;\n                sseEventSource.addEventListener(sseEventName, sseListener);\n            } else {\n                triggerErrorEvent(elt, \"htmx:noSSESourceError\");\n            }\n        }\n\n        function processSSETrigger(elt, handler, sseEventName) {\n            var sseSourceElt = getClosestMatch(elt, hasEventSource);\n            if (sseSourceElt) {\n                var sseEventSource = getInternalData(sseSourceElt).sseEventSource;\n                var sseListener = function () {\n                    if (!maybeCloseSSESource(sseSourceElt)) {\n                        if (bodyContains(elt)) {\n                            handler(elt);\n                        } else {\n                            sseEventSource.removeEventListener(sseEventName, sseListener);\n                        }\n                    }\n                };\n                getInternalData(elt).sseListener = sseListener;\n                sseEventSource.addEventListener(sseEventName, sseListener);\n            } else {\n                triggerErrorEvent(elt, \"htmx:noSSESourceError\");\n            }\n        }\n\n        function maybeCloseSSESource(elt) {\n            if (!bodyContains(elt)) {\n                getInternalData(elt).sseEventSource.close();\n                return true;\n            }\n        }\n\n        function hasEventSource(node) {\n            return getInternalData(node).sseEventSource != null;\n        }\n\n        //====================================================================\n\n        function loadImmediately(elt, handler, nodeData, delay) {\n            var load = function(){\n                if (!nodeData.loaded) {\n                    nodeData.loaded = true;\n                    handler(elt);\n                }\n            }\n            if (delay) {\n                setTimeout(load, delay);\n            } else {\n                load();\n            }\n        }\n\n        function processVerbs(elt, nodeData, triggerSpecs) {\n            var explicitAction = false;\n            forEach(VERBS, function (verb) {\n                if (hasAttribute(elt,'hx-' + verb)) {\n                    var path = getAttributeValue(elt, 'hx-' + verb);\n                    explicitAction = true;\n                    nodeData.path = path;\n                    nodeData.verb = verb;\n                    triggerSpecs.forEach(function(triggerSpec) {\n                        addTriggerHandler(elt, triggerSpec, nodeData, function (elt, evt) {\n                            issueAjaxRequest(verb, path, elt, evt)\n                        })\n                    });\n                }\n            });\n            return explicitAction;\n        }\n\n        function addTriggerHandler(elt, triggerSpec, nodeData, handler) {\n            if (triggerSpec.sseEvent) {\n                processSSETrigger(elt, handler, triggerSpec.sseEvent);\n            } else if (triggerSpec.trigger === \"revealed\") {\n                initScrollHandler();\n                addEventListener(elt, handler, nodeData, triggerSpec);\n                maybeReveal(elt);\n            } else if (triggerSpec.trigger === \"intersect\") {\n                var observerOptions = {};\n                if (triggerSpec.root) {\n                    observerOptions.root = querySelectorExt(elt, triggerSpec.root)\n                }\n                if (triggerSpec.threshold) {\n                    observerOptions.threshold = parseFloat(triggerSpec.threshold);\n                }\n                var observer = new IntersectionObserver(function (entries) {\n                    for (var i = 0; i < entries.length; i++) {\n                        var entry = entries[i];\n                        if (entry.isIntersecting) {\n                            triggerEvent(elt, \"intersect\");\n                            break;\n                        }\n                    }\n                }, observerOptions);\n                observer.observe(elt);\n                addEventListener(elt, handler, nodeData, triggerSpec);\n            } else if (triggerSpec.trigger === \"load\") {\n                if (!maybeFilterEvent(triggerSpec, makeEvent(\"load\", {elt:elt}))) {\n                                loadImmediately(elt, handler, nodeData, triggerSpec.delay);\n                            }\n            } else if (triggerSpec.pollInterval) {\n                nodeData.polling = true;\n                processPolling(elt, handler, triggerSpec);\n            } else {\n                addEventListener(elt, handler, nodeData, triggerSpec);\n            }\n        }\n\n        function evalScript(script) {\n            if (script.type === \"text/javascript\" || script.type === \"module\" || script.type === \"\") {\n                var newScript = getDocument().createElement(\"script\");\n                forEach(script.attributes, function (attr) {\n                    newScript.setAttribute(attr.name, attr.value);\n                });\n                newScript.textContent = script.textContent;\n                newScript.async = false;\n                if (htmx.config.inlineScriptNonce) {\n                    newScript.nonce = htmx.config.inlineScriptNonce;\n                }\n                var parent = script.parentElement;\n\n                try {\n                    parent.insertBefore(newScript, script);\n                } catch (e) {\n                    logError(e);\n                } finally {\n                    // remove old script element, but only if it is still in DOM\n                    if (script.parentElement) {\n                        script.parentElement.removeChild(script);\n                    }\n                }\n            }\n        }\n\n        function processScripts(elt) {\n            if (matches(elt, \"script\")) {\n                evalScript(elt);\n            }\n            forEach(findAll(elt, \"script\"), function (script) {\n                evalScript(script);\n            });\n        }\n\n        function hasChanceOfBeingBoosted() {\n            return document.querySelector(\"[hx-boost], [data-hx-boost]\");\n        }\n\n        function findElementsToProcess(elt) {\n            if (elt.querySelectorAll) {\n                var boostedElts = hasChanceOfBeingBoosted() ? \", a, form\" : \"\";\n                var results = elt.querySelectorAll(VERB_SELECTOR + boostedElts + \", [hx-sse], [data-hx-sse], [hx-ws],\" +\n                    \" [data-hx-ws], [hx-ext], [data-hx-ext]\");\n                return results;\n            } else {\n                return [];\n            }\n        }\n\n        function initButtonTracking(form){\n            var maybeSetLastButtonClicked = function(evt){\n                var elt = closest(evt.target, \"button, input[type='submit']\");\n                if (elt !== null) {\n                    var internalData = getInternalData(form);\n                    internalData.lastButtonClicked = elt;\n                }\n            };\n\n            // need to handle both click and focus in:\n            //   focusin - in case someone tabs in to a button and hits the space bar\n            //   click - on OSX buttons do not focus on click see https://bugs.webkit.org/show_bug.cgi?id=13724\n\n            form.addEventListener('click', maybeSetLastButtonClicked)\n            form.addEventListener('focusin', maybeSetLastButtonClicked)\n            form.addEventListener('focusout', function(evt){\n                var internalData = getInternalData(form);\n                internalData.lastButtonClicked = null;\n            })\n        }\n\n        function initNode(elt) {\n            if (elt.closest && elt.closest(htmx.config.disableSelector)) {\n                return;\n            }\n            var nodeData = getInternalData(elt);\n            if (nodeData.initHash !== attributeHash(elt)) {\n\n                nodeData.initHash = attributeHash(elt);\n\n                // clean up any previously processed info\n                deInitNode(elt);\n\n                triggerEvent(elt, \"htmx:beforeProcessNode\")\n\n                if (elt.value) {\n                    nodeData.lastValue = elt.value;\n                }\n\n                var triggerSpecs = getTriggerSpecs(elt);\n                var explicitAction = processVerbs(elt, nodeData, triggerSpecs);\n\n                if (!explicitAction && getClosestAttributeValue(elt, \"hx-boost\") === \"true\") {\n                    boostElement(elt, nodeData, triggerSpecs);\n                }\n\n                if (elt.tagName === \"FORM\") {\n                    initButtonTracking(elt);\n                }\n\n                var sseInfo = getAttributeValue(elt, 'hx-sse');\n                if (sseInfo) {\n                    processSSEInfo(elt, nodeData, sseInfo);\n                }\n\n                var wsInfo = getAttributeValue(elt, 'hx-ws');\n                if (wsInfo) {\n                    processWebSocketInfo(elt, nodeData, wsInfo);\n                }\n                triggerEvent(elt, \"htmx:afterProcessNode\");\n            }\n        }\n\n        function processNode(elt) {\n            elt = resolveTarget(elt);\n            initNode(elt);\n            forEach(findElementsToProcess(elt), function(child) { initNode(child) });\n        }\n\n        //====================================================================\n        // Event/Log Support\n        //====================================================================\n\n        function kebabEventName(str) {\n            return str.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();\n        }\n\n        function makeEvent(eventName, detail) {\n            var evt;\n            if (window.CustomEvent && typeof window.CustomEvent === 'function') {\n                evt = new CustomEvent(eventName, {bubbles: true, cancelable: true, detail: detail});\n            } else {\n                evt = getDocument().createEvent('CustomEvent');\n                evt.initCustomEvent(eventName, true, true, detail);\n            }\n            return evt;\n        }\n\n        function triggerErrorEvent(elt, eventName, detail) {\n            triggerEvent(elt, eventName, mergeObjects({error:eventName}, detail));\n        }\n\n        function ignoreEventForLogging(eventName) {\n            return eventName === \"htmx:afterProcessNode\"\n        }\n\n        /**\n         * `withExtensions` locates all active extensions for a provided element, then\n         * executes the provided function using each of the active extensions.  It should\n         * be called internally at every extendable execution point in htmx.\n         *\n         * @param {HTMLElement} elt\n         * @param {(extension:import(\"./htmx\").HtmxExtension) => void} toDo\n         * @returns void\n         */\n        function withExtensions(elt, toDo) {\n            forEach(getExtensions(elt), function(extension){\n                try {\n                    toDo(extension);\n                } catch (e) {\n                    logError(e);\n                }\n            });\n        }\n\n        function logError(msg) {\n            if(console.error) {\n                console.error(msg);\n            } else if (console.log) {\n                console.log(\"ERROR: \", msg);\n            }\n        }\n\n        function triggerEvent(elt, eventName, detail) {\n            elt = resolveTarget(elt);\n            if (detail == null) {\n                detail = {};\n            }\n            detail[\"elt\"] = elt;\n            var event = makeEvent(eventName, detail);\n            if (htmx.logger && !ignoreEventForLogging(eventName)) {\n                htmx.logger(elt, eventName, detail);\n            }\n            if (detail.error) {\n                logError(detail.error);\n                triggerEvent(elt, \"htmx:error\", {errorInfo:detail})\n            }\n            var eventResult = elt.dispatchEvent(event);\n            var kebabName = kebabEventName(eventName);\n            if (eventResult && kebabName !== eventName) {\n                var kebabedEvent = makeEvent(kebabName, event.detail);\n                eventResult = eventResult && elt.dispatchEvent(kebabedEvent)\n            }\n            withExtensions(elt, function (extension) {\n                eventResult = eventResult && (extension.onEvent(eventName, event) !== false)\n            });\n            return eventResult;\n        }\n\n        //====================================================================\n        // History Support\n        //====================================================================\n        var currentPathForHistory = location.pathname+location.search;\n\n        function getHistoryElement() {\n            var historyElt = getDocument().querySelector('[hx-history-elt],[data-hx-history-elt]');\n            return historyElt || getDocument().body;\n        }\n\n        function saveToHistoryCache(url, content, title, scroll) {\n            if (!canAccessLocalStorage()) {\n                return;\n            }\n\n            var historyCache = parseJSON(localStorage.getItem(\"htmx-history-cache\")) || [];\n            for (var i = 0; i < historyCache.length; i++) {\n                if (historyCache[i].url === url) {\n                    historyCache.splice(i, 1);\n                    break;\n                }\n            }\n            var newHistoryItem = {url:url, content: content, title:title, scroll:scroll};\n            triggerEvent(getDocument().body, \"htmx:historyItemCreated\", {item:newHistoryItem, cache: historyCache})\n            historyCache.push(newHistoryItem)\n            while (historyCache.length > htmx.config.historyCacheSize) {\n                historyCache.shift();\n            }\n            while(historyCache.length > 0){\n                try {\n                    localStorage.setItem(\"htmx-history-cache\", JSON.stringify(historyCache));\n                    break;\n                } catch (e) {\n                    triggerErrorEvent(getDocument().body, \"htmx:historyCacheError\", {cause:e, cache: historyCache})\n                    historyCache.shift(); // shrink the cache and retry\n                }\n            }\n        }\n\n        function getCachedHistory(url) {\n            if (!canAccessLocalStorage()) {\n                return null;\n            }\n\n            var historyCache = parseJSON(localStorage.getItem(\"htmx-history-cache\")) || [];\n            for (var i = 0; i < historyCache.length; i++) {\n                if (historyCache[i].url === url) {\n                    return historyCache[i];\n                }\n            }\n            return null;\n        }\n\n        function cleanInnerHtmlForHistory(elt) {\n            var className = htmx.config.requestClass;\n            var clone = elt.cloneNode(true);\n            forEach(findAll(clone, \".\" + className), function(child){\n                removeClassFromElement(child, className);\n            });\n            return clone.innerHTML;\n        }\n\n        function saveCurrentPageToHistory() {\n            var elt = getHistoryElement();\n            var path = currentPathForHistory || location.pathname+location.search;\n\n            // Allow history snapshot feature to be disabled where hx-history=\"false\"\n            // is present *anywhere* in the current document we're about to save,\n            // so we can prevent privileged data entering the cache.\n            // The page will still be reachable as a history entry, but htmx will fetch it\n            // live from the server onpopstate rather than look in the localStorage cache\n            var disableHistoryCache = getDocument().querySelector('[hx-history=\"false\" i],[data-hx-history=\"false\" i]');\n            if (!disableHistoryCache) {\n                triggerEvent(getDocument().body, \"htmx:beforeHistorySave\", {path: path, historyElt: elt});\n                saveToHistoryCache(path, cleanInnerHtmlForHistory(elt), getDocument().title, window.scrollY);\n            }\n\n            if (htmx.config.historyEnabled) history.replaceState({htmx: true}, getDocument().title, window.location.href);\n        }\n\n        function pushUrlIntoHistory(path) {\n            // remove the cache buster parameter, if any\n            if (htmx.config.getCacheBusterParam) {\n                path = path.replace(/org\\.htmx\\.cache-buster=[^&]*&?/, '')\n                if (path.endsWith('&') || path.endsWith(\"?\")) {\n                    path = path.slice(0, -1);\n                }\n            }\n            if(htmx.config.historyEnabled) {\n                history.pushState({htmx:true}, \"\", path);\n            }\n            currentPathForHistory = path;\n        }\n\n        function replaceUrlInHistory(path) {\n            if(htmx.config.historyEnabled)  history.replaceState({htmx:true}, \"\", path);\n            currentPathForHistory = path;\n        }\n\n        function settleImmediately(tasks) {\n            forEach(tasks, function (task) {\n                task.call();\n            });\n        }\n\n        function loadHistoryFromServer(path) {\n            var request = new XMLHttpRequest();\n            var details = {path: path, xhr:request};\n            triggerEvent(getDocument().body, \"htmx:historyCacheMiss\", details);\n            request.open('GET', path, true);\n            request.setRequestHeader(\"HX-History-Restore-Request\", \"true\");\n            request.onload = function () {\n                if (this.status >= 200 && this.status < 400) {\n                    triggerEvent(getDocument().body, \"htmx:historyCacheMissLoad\", details);\n                    var fragment = makeFragment(this.response);\n                    // @ts-ignore\n                    fragment = fragment.querySelector('[hx-history-elt],[data-hx-history-elt]') || fragment;\n                    var historyElement = getHistoryElement();\n                    var settleInfo = makeSettleInfo(historyElement);\n                    var title = findTitle(this.response);\n                    if (title) {\n                        var titleElt = find(\"title\");\n                        if (titleElt) {\n                            titleElt.innerHTML = title;\n                        } else {\n                            window.document.title = title;\n                        }\n                    }\n                    // @ts-ignore\n                    swapInnerHTML(historyElement, fragment, settleInfo)\n                    settleImmediately(settleInfo.tasks);\n                    currentPathForHistory = path;\n                    triggerEvent(getDocument().body, \"htmx:historyRestore\", {path: path, cacheMiss:true, serverResponse:this.response});\n                } else {\n                    triggerErrorEvent(getDocument().body, \"htmx:historyCacheMissLoadError\", details);\n                }\n            };\n            request.send();\n        }\n\n        function restoreHistory(path) {\n            saveCurrentPageToHistory();\n            path = path || location.pathname+location.search;\n            var cached = getCachedHistory(path);\n            if (cached) {\n                var fragment = makeFragment(cached.content);\n                var historyElement = getHistoryElement();\n                var settleInfo = makeSettleInfo(historyElement);\n                swapInnerHTML(historyElement, fragment, settleInfo)\n                settleImmediately(settleInfo.tasks);\n                document.title = cached.title;\n                window.scrollTo(0, cached.scroll);\n                currentPathForHistory = path;\n                triggerEvent(getDocument().body, \"htmx:historyRestore\", {path:path, item:cached});\n            } else {\n                if (htmx.config.refreshOnHistoryMiss) {\n\n                    // @ts-ignore: optional parameter in reload() function throws error\n                    window.location.reload(true);\n                } else {\n                    loadHistoryFromServer(path);\n                }\n            }\n        }\n\n        function addRequestIndicatorClasses(elt) {\n            var indicators = findAttributeTargets(elt, 'hx-indicator');\n            if (indicators == null) {\n                indicators = [elt];\n            }\n            forEach(indicators, function (ic) {\n                var internalData = getInternalData(ic);\n                internalData.requestCount = (internalData.requestCount || 0) + 1;\n                ic.classList[\"add\"].call(ic.classList, htmx.config.requestClass);\n            });\n            return indicators;\n        }\n\n        function removeRequestIndicatorClasses(indicators) {\n            forEach(indicators, function (ic) {\n                var internalData = getInternalData(ic);\n                internalData.requestCount = (internalData.requestCount || 0) - 1;\n                if (internalData.requestCount === 0) {\n                    ic.classList[\"remove\"].call(ic.classList, htmx.config.requestClass);\n                }\n            });\n        }\n\n        //====================================================================\n        // Input Value Processing\n        //====================================================================\n\n        function haveSeenNode(processed, elt) {\n            for (var i = 0; i < processed.length; i++) {\n                var node = processed[i];\n                if (node.isSameNode(elt)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        function shouldInclude(elt) {\n            if(elt.name === \"\" || elt.name == null || elt.disabled) {\n                return false;\n            }\n            // ignore \"submitter\" types (see jQuery src/serialize.js)\n            if (elt.type === \"button\" || elt.type === \"submit\" || elt.tagName === \"image\" || elt.tagName === \"reset\" || elt.tagName === \"file\" ) {\n                return false;\n            }\n            if (elt.type === \"checkbox\" || elt.type === \"radio\" ) {\n                return elt.checked;\n            }\n            return true;\n        }\n\n        function processInputValue(processed, values, errors, elt, validate) {\n            if (elt == null || haveSeenNode(processed, elt)) {\n                return;\n            } else {\n                processed.push(elt);\n            }\n            if (shouldInclude(elt)) {\n                var name = getRawAttribute(elt,\"name\");\n                var value = elt.value;\n                if (elt.multiple) {\n                    value = toArray(elt.querySelectorAll(\"option:checked\")).map(function (e) { return e.value });\n                }\n                // include file inputs\n                if (elt.files) {\n                    value = toArray(elt.files);\n                }\n                // This is a little ugly because both the current value of the named value in the form\n                // and the new value could be arrays, so we have to handle all four cases :/\n                if (name != null && value != null) {\n                    var current = values[name];\n                    if (current !== undefined) {\n                        if (Array.isArray(current)) {\n                            if (Array.isArray(value)) {\n                                values[name] = current.concat(value);\n                            } else {\n                                current.push(value);\n                            }\n                        } else {\n                            if (Array.isArray(value)) {\n                                values[name] = [current].concat(value);\n                            } else {\n                                values[name] = [current, value];\n                            }\n                        }\n                    } else {\n                        values[name] = value;\n                    }\n                }\n                if (validate) {\n                    validateElement(elt, errors);\n                }\n            }\n            if (matches(elt, 'form')) {\n                var inputs = elt.elements;\n                forEach(inputs, function(input) {\n                    processInputValue(processed, values, errors, input, validate);\n                });\n            }\n        }\n\n        function validateElement(element, errors) {\n            if (element.willValidate) {\n                triggerEvent(element, \"htmx:validation:validate\")\n                if (!element.checkValidity()) {\n                    errors.push({elt: element, message:element.validationMessage, validity:element.validity});\n                    triggerEvent(element, \"htmx:validation:failed\", {message:element.validationMessage, validity:element.validity})\n                }\n            }\n        }\n\n        /**\n         * @param {HTMLElement} elt\n         * @param {string} verb\n         */\n        function getInputValues(elt, verb) {\n            var processed = [];\n            var values = {};\n            var formValues = {};\n            var errors = [];\n            var internalData = getInternalData(elt);\n\n            // only validate when form is directly submitted and novalidate or formnovalidate are not set\n            // or if the element has an explicit hx-validate=\"true\" on it\n            var validate = (matches(elt, 'form') && elt.noValidate !== true) || getAttributeValue(elt, \"hx-validate\") === \"true\";\n            if (internalData.lastButtonClicked) {\n                validate = validate && internalData.lastButtonClicked.formNoValidate !== true;\n            }\n\n            // for a non-GET include the closest form\n            if (verb !== 'get') {\n                processInputValue(processed, formValues, errors, closest(elt, 'form'), validate);\n            }\n\n            // include the element itself\n            processInputValue(processed, values, errors, elt, validate);\n\n            // if a button or submit was clicked last, include its value\n            if (internalData.lastButtonClicked) {\n                var name = getRawAttribute(internalData.lastButtonClicked,\"name\");\n                if (name) {\n                    values[name] = internalData.lastButtonClicked.value;\n                }\n            }\n\n            // include any explicit includes\n            var includes = findAttributeTargets(elt, \"hx-include\");\n            forEach(includes, function(node) {\n                processInputValue(processed, values, errors, node, validate);\n                // if a non-form is included, include any input values within it\n                if (!matches(node, 'form')) {\n                    forEach(node.querySelectorAll(INPUT_SELECTOR), function (descendant) {\n                        processInputValue(processed, values, errors, descendant, validate);\n                    })\n                }\n            });\n\n            // form values take precedence, overriding the regular values\n            values = mergeObjects(values, formValues);\n\n            return {errors:errors, values:values};\n        }\n\n        function appendParam(returnStr, name, realValue) {\n            if (returnStr !== \"\") {\n                returnStr += \"&\";\n            }\n            if (String(realValue) === \"[object Object]\") {\n                realValue = JSON.stringify(realValue);\n            }\n            var s = encodeURIComponent(realValue);\n            returnStr += encodeURIComponent(name) + \"=\" + s;\n            return returnStr;\n        }\n\n        function urlEncode(values) {\n            var returnStr = \"\";\n            for (var name in values) {\n                if (values.hasOwnProperty(name)) {\n                    var value = values[name];\n                    if (Array.isArray(value)) {\n                        forEach(value, function(v) {\n                            returnStr = appendParam(returnStr, name, v);\n                        });\n                    } else {\n                        returnStr = appendParam(returnStr, name, value);\n                    }\n                }\n            }\n            return returnStr;\n        }\n\n        function makeFormData(values) {\n            var formData = new FormData();\n            for (var name in values) {\n                if (values.hasOwnProperty(name)) {\n                    var value = values[name];\n                    if (Array.isArray(value)) {\n                        forEach(value, function(v) {\n                            formData.append(name, v);\n                        });\n                    } else {\n                        formData.append(name, value);\n                    }\n                }\n            }\n            return formData;\n        }\n\n        //====================================================================\n        // Ajax\n        //====================================================================\n\n        /**\n         * @param {HTMLElement} elt\n         * @param {HTMLElement} target\n         * @param {string} prompt\n         * @returns {Object} // TODO: Define/Improve HtmxHeaderSpecification\n         */\n        function getHeaders(elt, target, prompt) {\n            var headers = {\n                \"HX-Request\" : \"true\",\n                \"HX-Trigger\" : getRawAttribute(elt, \"id\"),\n                \"HX-Trigger-Name\" : getRawAttribute(elt, \"name\"),\n                \"HX-Target\" : getAttributeValue(target, \"id\"),\n                \"HX-Current-URL\" : getDocument().location.href,\n            }\n            getValuesForElement(elt, \"hx-headers\", false, headers)\n            if (prompt !== undefined) {\n                headers[\"HX-Prompt\"] = prompt;\n            }\n            if (getInternalData(elt).boosted) {\n                headers[\"HX-Boosted\"] = \"true\";\n            }\n            return headers;\n        }\n\n        /**\n         * filterValues takes an object containing form input values\n         * and returns a new object that only contains keys that are\n         * specified by the closest \"hx-params\" attribute\n         * @param {Object} inputValues\n         * @param {HTMLElement} elt\n         * @returns {Object}\n         */\n        function filterValues(inputValues, elt) {\n            var paramsValue = getClosestAttributeValue(elt, \"hx-params\");\n            if (paramsValue) {\n                if (paramsValue === \"none\") {\n                    return {};\n                } else if (paramsValue === \"*\") {\n                    return inputValues;\n                } else if(paramsValue.indexOf(\"not \") === 0) {\n                    forEach(paramsValue.substr(4).split(\",\"), function (name) {\n                        name = name.trim();\n                        delete inputValues[name];\n                    });\n                    return inputValues;\n                } else {\n                    var newValues = {}\n                    forEach(paramsValue.split(\",\"), function (name) {\n                        name = name.trim();\n                        newValues[name] = inputValues[name];\n                    });\n                    return newValues;\n                }\n            } else {\n                return inputValues;\n            }\n        }\n\n        function isAnchorLink(elt) {\n          return getRawAttribute(elt, 'href') && getRawAttribute(elt, 'href').indexOf(\"#\") >=0\n        }\n\n        /**\n         *\n         * @param {HTMLElement} elt\n         * @param {string} swapInfoOverride\n         * @returns {import(\"./htmx\").HtmxSwapSpecification}\n         */\n        function getSwapSpecification(elt, swapInfoOverride) {\n            var swapInfo = swapInfoOverride ? swapInfoOverride : getClosestAttributeValue(elt, \"hx-swap\");\n            var swapSpec = {\n                \"swapStyle\" : getInternalData(elt).boosted ? 'innerHTML' : htmx.config.defaultSwapStyle,\n                \"swapDelay\" : htmx.config.defaultSwapDelay,\n                \"settleDelay\" : htmx.config.defaultSettleDelay\n            }\n            if (getInternalData(elt).boosted && !isAnchorLink(elt)) {\n              swapSpec[\"show\"] = \"top\"\n            }\n            if (swapInfo) {\n                var split = splitOnWhitespace(swapInfo);\n                if (split.length > 0) {\n                    swapSpec[\"swapStyle\"] = split[0];\n                    for (var i = 1; i < split.length; i++) {\n                        var modifier = split[i];\n                        if (modifier.indexOf(\"swap:\") === 0) {\n                            swapSpec[\"swapDelay\"] = parseInterval(modifier.substr(5));\n                        }\n                        if (modifier.indexOf(\"settle:\") === 0) {\n                            swapSpec[\"settleDelay\"] = parseInterval(modifier.substr(7));\n                        }\n                        if (modifier.indexOf(\"scroll:\") === 0) {\n                            var scrollSpec = modifier.substr(7);\n                            var splitSpec = scrollSpec.split(\":\");\n                            var scrollVal = splitSpec.pop();\n                            var selectorVal = splitSpec.length > 0 ? splitSpec.join(\":\") : null;\n                            swapSpec[\"scroll\"] = scrollVal;\n                            swapSpec[\"scrollTarget\"] = selectorVal;\n                        }\n                        if (modifier.indexOf(\"show:\") === 0) {\n                            var showSpec = modifier.substr(5);\n                            var splitSpec = showSpec.split(\":\");\n                            var showVal = splitSpec.pop();\n                            var selectorVal = splitSpec.length > 0 ? splitSpec.join(\":\") : null;\n                            swapSpec[\"show\"] = showVal;\n                            swapSpec[\"showTarget\"] = selectorVal;\n                        }\n                        if (modifier.indexOf(\"focus-scroll:\") === 0) {\n                            var focusScrollVal = modifier.substr(\"focus-scroll:\".length);\n                            swapSpec[\"focusScroll\"] = focusScrollVal == \"true\";\n                        }\n                    }\n                }\n            }\n            return swapSpec;\n        }\n\n        function usesFormData(elt) {\n            return getClosestAttributeValue(elt, \"hx-encoding\") === \"multipart/form-data\" ||\n                (matches(elt, \"form\") && getRawAttribute(elt, 'enctype') === \"multipart/form-data\");\n        }\n\n        function encodeParamsForBody(xhr, elt, filteredParameters) {\n            var encodedParameters = null;\n            withExtensions(elt, function (extension) {\n                if (encodedParameters == null) {\n                    encodedParameters = extension.encodeParameters(xhr, filteredParameters, elt);\n                }\n            });\n            if (encodedParameters != null) {\n                return encodedParameters;\n            } else {\n                if (usesFormData(elt)) {\n                    return makeFormData(filteredParameters);\n                } else {\n                    return urlEncode(filteredParameters);\n                }\n            }\n        }\n\n        /**\n         *\n         * @param {Element} target\n         * @returns {import(\"./htmx\").HtmxSettleInfo}\n         */\n        function makeSettleInfo(target) {\n            return {tasks: [], elts: [target]};\n        }\n\n        function updateScrollState(content, swapSpec) {\n            var first = content[0];\n            var last = content[content.length - 1];\n            if (swapSpec.scroll) {\n                var target = null;\n                if (swapSpec.scrollTarget) {\n                    target = querySelectorExt(first, swapSpec.scrollTarget);\n                }\n                if (swapSpec.scroll === \"top\" && (first || target)) {\n                    target = target || first;\n                    target.scrollTop = 0;\n                }\n                if (swapSpec.scroll === \"bottom\" && (last || target)) {\n                    target = target || last;\n                    target.scrollTop = target.scrollHeight;\n                }\n            }\n            if (swapSpec.show) {\n                var target = null;\n                if (swapSpec.showTarget) {\n                    var targetStr = swapSpec.showTarget;\n                    if (swapSpec.showTarget === \"window\") {\n                        targetStr = \"body\";\n                    }\n                    target = querySelectorExt(first, targetStr);\n                }\n                if (swapSpec.show === \"top\" && (first || target)) {\n                    target = target || first;\n                    target.scrollIntoView({block:'start', behavior: htmx.config.scrollBehavior});\n                }\n                if (swapSpec.show === \"bottom\" && (last || target)) {\n                    target = target || last;\n                    target.scrollIntoView({block:'end', behavior: htmx.config.scrollBehavior});\n                }\n            }\n        }\n\n        /**\n         * @param {HTMLElement} elt\n         * @param {string} attr\n         * @param {boolean=} evalAsDefault\n         * @param {Object=} values\n         * @returns {Object}\n         */\n        function getValuesForElement(elt, attr, evalAsDefault, values) {\n            if (values == null) {\n                values = {};\n            }\n            if (elt == null) {\n                return values;\n            }\n            var attributeValue = getAttributeValue(elt, attr);\n            if (attributeValue) {\n                var str = attributeValue.trim();\n                var evaluateValue = evalAsDefault;\n                if (str === \"unset\") {\n                    return null;\n                }\n                if (str.indexOf(\"javascript:\") === 0) {\n                    str = str.substr(11);\n                    evaluateValue = true;\n                } else if (str.indexOf(\"js:\") === 0) {\n                    str = str.substr(3);\n                    evaluateValue = true;\n                }\n                if (str.indexOf('{') !== 0) {\n                    str = \"{\" + str + \"}\";\n                }\n                var varsValues;\n                if (evaluateValue) {\n                    varsValues = maybeEval(elt,function () {return Function(\"return (\" + str + \")\")();}, {});\n                } else {\n                    varsValues = parseJSON(str);\n                }\n                for (var key in varsValues) {\n                    if (varsValues.hasOwnProperty(key)) {\n                        if (values[key] == null) {\n                            values[key] = varsValues[key];\n                        }\n                    }\n                }\n            }\n            return getValuesForElement(parentElt(elt), attr, evalAsDefault, values);\n        }\n\n        function maybeEval(elt, toEval, defaultVal) {\n            if (htmx.config.allowEval) {\n                return toEval();\n            } else {\n                triggerErrorEvent(elt, 'htmx:evalDisallowedError');\n                return defaultVal;\n            }\n        }\n\n        /**\n         * @param {HTMLElement} elt\n         * @param {*} expressionVars\n         * @returns\n         */\n        function getHXVarsForElement(elt, expressionVars) {\n            return getValuesForElement(elt, \"hx-vars\", true, expressionVars);\n        }\n\n        /**\n         * @param {HTMLElement} elt\n         * @param {*} expressionVars\n         * @returns\n         */\n        function getHXValsForElement(elt, expressionVars) {\n            return getValuesForElement(elt, \"hx-vals\", false, expressionVars);\n        }\n\n        /**\n         * @param {HTMLElement} elt\n         * @returns {Object}\n         */\n        function getExpressionVars(elt) {\n            return mergeObjects(getHXVarsForElement(elt), getHXValsForElement(elt));\n        }\n\n        function safelySetHeaderValue(xhr, header, headerValue) {\n            if (headerValue !== null) {\n                try {\n                    xhr.setRequestHeader(header, headerValue);\n                } catch (e) {\n                    // On an exception, try to set the header URI encoded instead\n                    xhr.setRequestHeader(header, encodeURIComponent(headerValue));\n                    xhr.setRequestHeader(header + \"-URI-AutoEncoded\", \"true\");\n                }\n            }\n        }\n\n        function getPathFromResponse(xhr) {\n            // NB: IE11 does not support this stuff\n            if (xhr.responseURL && typeof(URL) !== \"undefined\") {\n                try {\n                    var url = new URL(xhr.responseURL);\n                    return url.pathname + url.search;\n                } catch (e) {\n                    triggerErrorEvent(getDocument().body, \"htmx:badResponseUrl\", {url: xhr.responseURL});\n                }\n            }\n        }\n\n        function hasHeader(xhr, regexp) {\n            return xhr.getAllResponseHeaders().match(regexp);\n        }\n\n        function ajaxHelper(verb, path, context) {\n            verb = verb.toLowerCase();\n            if (context) {\n                if (context instanceof Element || isType(context, 'String')) {\n                    return issueAjaxRequest(verb, path, null, null, {\n                        targetOverride: resolveTarget(context),\n                        returnPromise: true\n                    });\n                } else {\n                    return issueAjaxRequest(verb, path, resolveTarget(context.source), context.event,\n                        {\n                            handler : context.handler,\n                            headers : context.headers,\n                            values : context.values,\n                            targetOverride: resolveTarget(context.target),\n                            swapOverride: context.swap,\n                            returnPromise: true\n                        });\n                }\n            } else {\n                return issueAjaxRequest(verb, path, null, null, {\n                        returnPromise: true\n                });\n            }\n        }\n\n        function hierarchyForElt(elt) {\n            var arr = [];\n            while (elt) {\n                arr.push(elt);\n                elt = elt.parentElement;\n            }\n            return arr;\n        }\n\n        function issueAjaxRequest(verb, path, elt, event, etc, confirmed) {\n            var resolve = null;\n            var reject = null;\n            etc = etc != null ? etc : {};\n            if(etc.returnPromise && typeof Promise !== \"undefined\"){\n                var promise = new Promise(function (_resolve, _reject) {\n                    resolve = _resolve;\n                    reject = _reject;\n                });\n            }\n            if(elt == null) {\n                elt = getDocument().body;\n            }\n            var responseHandler = etc.handler || handleAjaxResponse;\n\n            if (!bodyContains(elt)) {\n                return; // do not issue requests for elements removed from the DOM\n            }\n            var target = etc.targetOverride || getTarget(elt);\n            if (target == null || target == DUMMY_ELT) {\n                triggerErrorEvent(elt, 'htmx:targetError', {target: getAttributeValue(elt, \"hx-target\")});\n                return;\n            }\n\n            // allow event-based confirmation w/ a callback\n            if (!confirmed) {\n                var issueRequest = function() {\n                    return issueAjaxRequest(verb, path, elt, event, etc, true);\n                }\n                var confirmDetails = {target: target, elt: elt, path: path, verb: verb, triggeringEvent: event, etc: etc, issueRequest: issueRequest};\n                if (triggerEvent(elt, 'htmx:confirm', confirmDetails) === false) {\n                    return;\n                }\n            }\n\n            var syncElt = elt;\n            var eltData = getInternalData(elt);\n            var syncStrategy = getClosestAttributeValue(elt, \"hx-sync\");\n            var queueStrategy = null;\n            var abortable = false;\n            if (syncStrategy) {\n                var syncStrings = syncStrategy.split(\":\");\n                var selector = syncStrings[0].trim();\n                if (selector === \"this\") {\n                    syncElt = findThisElement(elt, 'hx-sync');\n                } else {\n                    syncElt = querySelectorExt(elt, selector);\n                }\n                // default to the drop strategy\n                syncStrategy = (syncStrings[1] || 'drop').trim();\n                eltData = getInternalData(syncElt);\n                if (syncStrategy === \"drop\" && eltData.xhr && eltData.abortable !== true) {\n                    return;\n                } else if (syncStrategy === \"abort\") {\n                    if (eltData.xhr) {\n                        return;\n                    } else {\n                        abortable = true;\n                    }\n                } else if (syncStrategy === \"replace\") {\n                    triggerEvent(syncElt, 'htmx:abort'); // abort the current request and continue\n                } else if (syncStrategy.indexOf(\"queue\") === 0) {\n                    var queueStrArray = syncStrategy.split(\" \");\n                    queueStrategy = (queueStrArray[1] || \"last\").trim();\n                }\n            }\n\n            if (eltData.xhr) {\n                if (eltData.abortable) {\n                    triggerEvent(syncElt, 'htmx:abort'); // abort the current request and continue\n                } else {\n                    if(queueStrategy == null){\n                        if (event) {\n                            var eventData = getInternalData(event);\n                            if (eventData && eventData.triggerSpec && eventData.triggerSpec.queue) {\n                                queueStrategy = eventData.triggerSpec.queue;\n                            }\n                        }\n                        if (queueStrategy == null) {\n                            queueStrategy = \"last\";\n                        }\n                    }\n                    if (eltData.queuedRequests == null) {\n                        eltData.queuedRequests = [];\n                    }\n                    if (queueStrategy === \"first\" && eltData.queuedRequests.length === 0) {\n                        eltData.queuedRequests.push(function () {\n                            issueAjaxRequest(verb, path, elt, event, etc)\n                        });\n                    } else if (queueStrategy === \"all\") {\n                        eltData.queuedRequests.push(function () {\n                            issueAjaxRequest(verb, path, elt, event, etc)\n                        });\n                    } else if (queueStrategy === \"last\") {\n                        eltData.queuedRequests = []; // dump existing queue\n                        eltData.queuedRequests.push(function () {\n                            issueAjaxRequest(verb, path, elt, event, etc)\n                        });\n                    }\n                    return;\n                }\n            }\n\n            var xhr = new XMLHttpRequest();\n            eltData.xhr = xhr;\n            eltData.abortable = abortable;\n            var endRequestLock = function(){\n                eltData.xhr = null;\n                eltData.abortable = false;\n                if (eltData.queuedRequests != null &&\n                    eltData.queuedRequests.length > 0) {\n                    var queuedRequest = eltData.queuedRequests.shift();\n                    queuedRequest();\n                }\n            }\n            var promptQuestion = getClosestAttributeValue(elt, \"hx-prompt\");\n            if (promptQuestion) {\n                var promptResponse = prompt(promptQuestion);\n                // prompt returns null if cancelled and empty string if accepted with no entry\n                if (promptResponse === null ||\n                    !triggerEvent(elt, 'htmx:prompt', {prompt: promptResponse, target:target})) {\n                    maybeCall(resolve);\n                    endRequestLock();\n                    return promise;\n                }\n            }\n\n            var confirmQuestion = getClosestAttributeValue(elt, \"hx-confirm\");\n            if (confirmQuestion) {\n                if(!confirm(confirmQuestion)) {\n                    maybeCall(resolve);\n                    endRequestLock()\n                    return promise;\n                }\n            }\n\n\n            var headers = getHeaders(elt, target, promptResponse);\n            if (etc.headers) {\n                headers = mergeObjects(headers, etc.headers);\n            }\n            var results = getInputValues(elt, verb);\n            var errors = results.errors;\n            var rawParameters = results.values;\n            if (etc.values) {\n                rawParameters = mergeObjects(rawParameters, etc.values);\n            }\n            var expressionVars = getExpressionVars(elt);\n            var allParameters = mergeObjects(rawParameters, expressionVars);\n            var filteredParameters = filterValues(allParameters, elt);\n\n            if (verb !== 'get' && !usesFormData(elt)) {\n                headers['Content-Type'] = 'application/x-www-form-urlencoded';\n            }\n\n            if (htmx.config.getCacheBusterParam && verb === 'get') {\n                filteredParameters['org.htmx.cache-buster'] = getRawAttribute(target, \"id\") || \"true\";\n            }\n\n            // behavior of anchors w/ empty href is to use the current URL\n            if (path == null || path === \"\") {\n                path = getDocument().location.href;\n            }\n\n\n            var requestAttrValues = getValuesForElement(elt, 'hx-request');\n\n            var eltIsBoosted = getInternalData(elt).boosted;\n            var requestConfig = {\n                boosted: eltIsBoosted,\n                parameters: filteredParameters,\n                unfilteredParameters: allParameters,\n                headers:headers,\n                target:target,\n                verb:verb,\n                errors:errors,\n                withCredentials: etc.credentials || requestAttrValues.credentials || htmx.config.withCredentials,\n                timeout:  etc.timeout || requestAttrValues.timeout || htmx.config.timeout,\n                path:path,\n                triggeringEvent:event\n            };\n\n            if(!triggerEvent(elt, 'htmx:configRequest', requestConfig)){\n                maybeCall(resolve);\n                endRequestLock();\n                return promise;\n            }\n\n            // copy out in case the object was overwritten\n            path = requestConfig.path;\n            verb = requestConfig.verb;\n            headers = requestConfig.headers;\n            filteredParameters = requestConfig.parameters;\n            errors = requestConfig.errors;\n\n            if(errors && errors.length > 0){\n                triggerEvent(elt, 'htmx:validation:halted', requestConfig)\n                maybeCall(resolve);\n                endRequestLock();\n                return promise;\n            }\n\n            var splitPath = path.split(\"#\");\n            var pathNoAnchor = splitPath[0];\n            var anchor = splitPath[1];\n            var finalPathForGet = null;\n            if (verb === 'get') {\n                finalPathForGet = pathNoAnchor;\n                var values = Object.keys(filteredParameters).length !== 0;\n                if (values) {\n                    if (finalPathForGet.indexOf(\"?\") < 0) {\n                        finalPathForGet += \"?\";\n                    } else {\n                        finalPathForGet += \"&\";\n                    }\n                    finalPathForGet += urlEncode(filteredParameters);\n                    if (anchor) {\n                        finalPathForGet += \"#\" + anchor;\n                    }\n                }\n                xhr.open('GET', finalPathForGet, true);\n            } else {\n                xhr.open(verb.toUpperCase(), path, true);\n            }\n\n            xhr.overrideMimeType(\"text/html\");\n            xhr.withCredentials = requestConfig.withCredentials;\n            xhr.timeout = requestConfig.timeout;\n\n            // request headers\n            if (requestAttrValues.noHeaders) {\n                // ignore all headers\n            } else {\n                for (var header in headers) {\n                    if (headers.hasOwnProperty(header)) {\n                        var headerValue = headers[header];\n                        safelySetHeaderValue(xhr, header, headerValue);\n                    }\n                }\n            }\n\n            var responseInfo = {\n                xhr: xhr, target: target, requestConfig: requestConfig, etc: etc, boosted: eltIsBoosted,\n                pathInfo: {\n                    requestPath: path,\n                    finalRequestPath: finalPathForGet || path,\n                    anchor: anchor\n                }\n            };\n\n            xhr.onload = function () {\n                try {\n                    var hierarchy = hierarchyForElt(elt);\n                    responseInfo.pathInfo.responsePath = getPathFromResponse(xhr);\n                    responseHandler(elt, responseInfo);\n                    removeRequestIndicatorClasses(indicators);\n                    triggerEvent(elt, 'htmx:afterRequest', responseInfo);\n                    triggerEvent(elt, 'htmx:afterOnLoad', responseInfo);\n                    // if the body no longer contains the element, trigger the event on the closest parent\n                    // remaining in the DOM\n                    if (!bodyContains(elt)) {\n                        var secondaryTriggerElt = null;\n                        while (hierarchy.length > 0 && secondaryTriggerElt == null) {\n                            var parentEltInHierarchy = hierarchy.shift();\n                            if (bodyContains(parentEltInHierarchy)) {\n                                secondaryTriggerElt = parentEltInHierarchy;\n                            }\n                        }\n                        if (secondaryTriggerElt) {\n                            triggerEvent(secondaryTriggerElt, 'htmx:afterRequest', responseInfo);\n                            triggerEvent(secondaryTriggerElt, 'htmx:afterOnLoad', responseInfo);\n                        }\n                    }\n                    maybeCall(resolve);\n                    endRequestLock();\n                } catch (e) {\n                    triggerErrorEvent(elt, 'htmx:onLoadError', mergeObjects({error:e}, responseInfo));\n                    throw e;\n                }\n            }\n            xhr.onerror = function () {\n                removeRequestIndicatorClasses(indicators);\n                triggerErrorEvent(elt, 'htmx:afterRequest', responseInfo);\n                triggerErrorEvent(elt, 'htmx:sendError', responseInfo);\n                maybeCall(reject);\n                endRequestLock();\n            }\n            xhr.onabort = function() {\n                removeRequestIndicatorClasses(indicators);\n                triggerErrorEvent(elt, 'htmx:afterRequest', responseInfo);\n                triggerErrorEvent(elt, 'htmx:sendAbort', responseInfo);\n                maybeCall(reject);\n                endRequestLock();\n            }\n            xhr.ontimeout = function() {\n                removeRequestIndicatorClasses(indicators);\n                triggerErrorEvent(elt, 'htmx:afterRequest', responseInfo);\n                triggerErrorEvent(elt, 'htmx:timeout', responseInfo);\n                maybeCall(reject);\n                endRequestLock();\n            }\n            if(!triggerEvent(elt, 'htmx:beforeRequest', responseInfo)){\n                maybeCall(resolve);\n                endRequestLock()\n                return promise\n            }\n            var indicators = addRequestIndicatorClasses(elt);\n\n            forEach(['loadstart', 'loadend', 'progress', 'abort'], function(eventName) {\n                forEach([xhr, xhr.upload], function (target) {\n                    target.addEventListener(eventName, function(event){\n                        triggerEvent(elt, \"htmx:xhr:\" + eventName, {\n                            lengthComputable:event.lengthComputable,\n                            loaded:event.loaded,\n                            total:event.total\n                        });\n                    })\n                });\n            });\n            triggerEvent(elt, 'htmx:beforeSend', responseInfo);\n            xhr.send(verb === 'get' ? null : encodeParamsForBody(xhr, elt, filteredParameters));\n            return promise;\n        }\n\n        function determineHistoryUpdates(elt, responseInfo) {\n\n            var xhr = responseInfo.xhr;\n\n            //===========================================\n            // First consult response headers\n            //===========================================\n            var pathFromHeaders = null;\n            var typeFromHeaders = null;\n            if (hasHeader(xhr,/HX-Push:/i)) {\n                pathFromHeaders = xhr.getResponseHeader(\"HX-Push\");\n                typeFromHeaders = \"push\";\n            } else if (hasHeader(xhr,/HX-Push-Url:/i)) {\n                pathFromHeaders = xhr.getResponseHeader(\"HX-Push-Url\");\n                typeFromHeaders = \"push\";\n            } else if (hasHeader(xhr,/HX-Replace-Url:/i)) {\n                pathFromHeaders = xhr.getResponseHeader(\"HX-Replace-Url\");\n                typeFromHeaders = \"replace\";\n            }\n\n            // if there was a response header, that has priority\n            if (pathFromHeaders) {\n                if (pathFromHeaders === \"false\") {\n                    return {}\n                } else {\n                    return {\n                        type: typeFromHeaders,\n                        path : pathFromHeaders\n                    }\n                }\n            }\n\n            //===========================================\n            // Next resolve via DOM values\n            //===========================================\n            var requestPath =  responseInfo.pathInfo.finalRequestPath;\n            var responsePath =  responseInfo.pathInfo.responsePath;\n\n            var pushUrl = getClosestAttributeValue(elt, \"hx-push-url\");\n            var replaceUrl = getClosestAttributeValue(elt, \"hx-replace-url\");\n            var elementIsBoosted = getInternalData(elt).boosted;\n\n            var saveType = null;\n            var path = null;\n\n            if (pushUrl) {\n                saveType = \"push\";\n                path = pushUrl;\n            } else if (replaceUrl) {\n                saveType = \"replace\";\n                path = replaceUrl;\n            } else if (elementIsBoosted) {\n                saveType = \"push\";\n                path = responsePath || requestPath; // if there is no response path, go with the original request path\n            }\n\n            if (path) {\n                // false indicates no push, return empty object\n                if (path === \"false\") {\n                    return {};\n                }\n\n                // true indicates we want to follow wherever the server ended up sending us\n                if (path === \"true\") {\n                    path = responsePath || requestPath; // if there is no response path, go with the original request path\n                }\n\n                // restore any anchor associated with the request\n                if (responseInfo.pathInfo.anchor &&\n                    path.indexOf(\"#\") === -1) {\n                    path = path + \"#\" + responseInfo.pathInfo.anchor;\n                }\n\n                return {\n                    type:saveType,\n                    path: path\n                }\n            } else {\n                return {};\n            }\n        }\n\n        function handleAjaxResponse(elt, responseInfo) {\n            var xhr = responseInfo.xhr;\n            var target = responseInfo.target;\n            var etc = responseInfo.etc;\n\n            if (!triggerEvent(elt, 'htmx:beforeOnLoad', responseInfo)) return;\n\n            if (hasHeader(xhr, /HX-Trigger:/i)) {\n                handleTrigger(xhr, \"HX-Trigger\", elt);\n            }\n\n            if (hasHeader(xhr, /HX-Location:/i)) {\n                saveCurrentPageToHistory();\n                var redirectPath = xhr.getResponseHeader(\"HX-Location\");\n                var swapSpec;\n                if (redirectPath.indexOf(\"{\") === 0) {\n                    swapSpec = parseJSON(redirectPath);\n                    // what's the best way to throw an error if the user didn't include this\n                    redirectPath = swapSpec['path'];\n                    delete swapSpec['path'];\n                }\n                ajaxHelper('GET', redirectPath, swapSpec).then(function(){\n                    pushUrlIntoHistory(redirectPath);\n                });\n                return;\n            }\n\n            if (hasHeader(xhr, /HX-Redirect:/i)) {\n                location.href = xhr.getResponseHeader(\"HX-Redirect\");\n                return;\n            }\n\n            if (hasHeader(xhr,/HX-Refresh:/i)) {\n                if (\"true\" === xhr.getResponseHeader(\"HX-Refresh\")) {\n                    location.reload();\n                    return;\n                }\n            }\n\n            if (hasHeader(xhr,/HX-Retarget:/i)) {\n                responseInfo.target = getDocument().querySelector(xhr.getResponseHeader(\"HX-Retarget\"));\n            }\n\n            var historyUpdate = determineHistoryUpdates(elt, responseInfo);\n\n            // by default htmx only swaps on 200 return codes and does not swap\n            // on 204 'No Content'\n            // this can be ovverriden by responding to the htmx:beforeSwap event and\n            // overriding the detail.shouldSwap property\n            var shouldSwap = xhr.status >= 200 && xhr.status < 400 && xhr.status !== 204;\n            var serverResponse = xhr.response;\n            var isError = xhr.status >= 400;\n            var beforeSwapDetails = mergeObjects({shouldSwap: shouldSwap, serverResponse:serverResponse, isError:isError}, responseInfo);\n            if (!triggerEvent(target, 'htmx:beforeSwap', beforeSwapDetails)) return;\n\n            target = beforeSwapDetails.target; // allow re-targeting\n            serverResponse = beforeSwapDetails.serverResponse; // allow updating content\n            isError = beforeSwapDetails.isError; // allow updating error\n\n            responseInfo.target = target; // Make updated target available to response events\n            responseInfo.failed = isError; // Make failed property available to response events\n            responseInfo.successful = !isError; // Make successful property available to response events\n\n            if (beforeSwapDetails.shouldSwap) {\n                if (xhr.status === 286) {\n                    cancelPolling(elt);\n                }\n\n                withExtensions(elt, function (extension) {\n                    serverResponse = extension.transformResponse(serverResponse, xhr, elt);\n                });\n\n                // Save current page if there will be a history update\n                if (historyUpdate.type) {\n                    saveCurrentPageToHistory();\n                }\n\n                var swapOverride = etc.swapOverride;\n                if (hasHeader(xhr,/HX-Reswap:/i)) {\n                    swapOverride = xhr.getResponseHeader(\"HX-Reswap\");\n                }\n                var swapSpec = getSwapSpecification(elt, swapOverride);\n\n                target.classList.add(htmx.config.swappingClass);\n                var doSwap = function () {\n                    try {\n\n                        var activeElt = document.activeElement;\n                        var selectionInfo = {};\n                        try {\n                            selectionInfo = {\n                                elt: activeElt,\n                                // @ts-ignore\n                                start: activeElt ? activeElt.selectionStart : null,\n                                // @ts-ignore\n                                end: activeElt ? activeElt.selectionEnd : null\n                            };\n                        } catch (e) {\n                            // safari issue - see https://github.com/microsoft/playwright/issues/5894\n                        }\n\n                        var settleInfo = makeSettleInfo(target);\n                        selectAndSwap(swapSpec.swapStyle, target, elt, serverResponse, settleInfo);\n\n                        if (selectionInfo.elt &&\n                            !bodyContains(selectionInfo.elt) &&\n                            selectionInfo.elt.id) {\n                            var newActiveElt = document.getElementById(selectionInfo.elt.id);\n                            var focusOptions = { preventScroll: swapSpec.focusScroll !== undefined ? !swapSpec.focusScroll : !htmx.config.defaultFocusScroll };\n                            if (newActiveElt) {\n                                // @ts-ignore\n                                if (selectionInfo.start && newActiveElt.setSelectionRange) {\n                                    // @ts-ignore\n                                    try {\n                                        newActiveElt.setSelectionRange(selectionInfo.start, selectionInfo.end);\n                                    } catch (e) {\n                                        // the setSelectionRange method is present on fields that don't support it, so just let this fail\n                                    }\n                                }\n                                newActiveElt.focus(focusOptions);\n                            }\n                        }\n\n                        target.classList.remove(htmx.config.swappingClass);\n                        forEach(settleInfo.elts, function (elt) {\n                            if (elt.classList) {\n                                elt.classList.add(htmx.config.settlingClass);\n                            }\n                            triggerEvent(elt, 'htmx:afterSwap', responseInfo);\n                        });\n\n                        if (hasHeader(xhr, /HX-Trigger-After-Swap:/i)) {\n                            var finalElt = elt;\n                            if (!bodyContains(elt)) {\n                                finalElt = getDocument().body;\n                            }\n                            handleTrigger(xhr, \"HX-Trigger-After-Swap\", finalElt);\n                        }\n\n                        var doSettle = function () {\n                            forEach(settleInfo.tasks, function (task) {\n                                task.call();\n                            });\n                            forEach(settleInfo.elts, function (elt) {\n                                if (elt.classList) {\n                                    elt.classList.remove(htmx.config.settlingClass);\n                                }\n                                triggerEvent(elt, 'htmx:afterSettle', responseInfo);\n                            });\n\n                            // if we need to save history, do so\n                            if (historyUpdate.type) {\n                                if (historyUpdate.type === \"push\") {\n                                    pushUrlIntoHistory(historyUpdate.path);\n                                    triggerEvent(getDocument().body, 'htmx:pushedIntoHistory', {path: historyUpdate.path});\n                                } else {\n                                    replaceUrlInHistory(historyUpdate.path);\n                                    triggerEvent(getDocument().body, 'htmx:replacedInHistory', {path: historyUpdate.path});\n                                }\n                            }\n                            if (responseInfo.pathInfo.anchor) {\n                                var anchorTarget = find(\"#\" + responseInfo.pathInfo.anchor);\n                                if(anchorTarget) {\n                                    anchorTarget.scrollIntoView({block:'start', behavior: \"auto\"});\n                                }\n                            }\n\n                            if(settleInfo.title) {\n                                var titleElt = find(\"title\");\n                                if(titleElt) {\n                                    titleElt.innerHTML = settleInfo.title;\n                                } else {\n                                    window.document.title = settleInfo.title;\n                                }\n                            }\n\n                            updateScrollState(settleInfo.elts, swapSpec);\n\n                            if (hasHeader(xhr, /HX-Trigger-After-Settle:/i)) {\n                                var finalElt = elt;\n                                if (!bodyContains(elt)) {\n                                    finalElt = getDocument().body;\n                                }\n                                handleTrigger(xhr, \"HX-Trigger-After-Settle\", finalElt);\n                            }\n                        }\n\n                        if (swapSpec.settleDelay > 0) {\n                            setTimeout(doSettle, swapSpec.settleDelay)\n                        } else {\n                            doSettle();\n                        }\n                    } catch (e) {\n                        triggerErrorEvent(elt, 'htmx:swapError', responseInfo);\n                        throw e;\n                    }\n                };\n\n                if (swapSpec.swapDelay > 0) {\n                    setTimeout(doSwap, swapSpec.swapDelay)\n                } else {\n                    doSwap();\n                }\n            }\n            if (isError) {\n                triggerErrorEvent(elt, 'htmx:responseError', mergeObjects({error: \"Response Status Error Code \" + xhr.status + \" from \" + responseInfo.pathInfo.requestPath}, responseInfo));\n            }\n        }\n\n        //====================================================================\n        // Extensions API\n        //====================================================================\n\n        /** @type {Object<string, import(\"./htmx\").HtmxExtension>} */\n        var extensions = {};\n\n        /**\n         * extensionBase defines the default functions for all extensions.\n         * @returns {import(\"./htmx\").HtmxExtension}\n         */\n        function extensionBase() {\n            return {\n                init: function(api) {return null;},\n                onEvent : function(name, evt) {return true;},\n                transformResponse : function(text, xhr, elt) {return text;},\n                isInlineSwap : function(swapStyle) {return false;},\n                handleSwap : function(swapStyle, target, fragment, settleInfo) {return false;},\n                encodeParameters : function(xhr, parameters, elt) {return null;}\n            }\n        }\n\n        /**\n         * defineExtension initializes the extension and adds it to the htmx registry\n         *\n         * @param {string} name\n         * @param {import(\"./htmx\").HtmxExtension} extension\n         */\n        function defineExtension(name, extension) {\n            if(extension.init) {\n                extension.init(internalAPI)\n            }\n            extensions[name] = mergeObjects(extensionBase(), extension);\n        }\n\n        /**\n         * removeExtension removes an extension from the htmx registry\n         *\n         * @param {string} name\n         */\n        function removeExtension(name) {\n            delete extensions[name];\n        }\n\n        /**\n         * getExtensions searches up the DOM tree to return all extensions that can be applied to a given element\n         *\n         * @param {HTMLElement} elt\n         * @param {import(\"./htmx\").HtmxExtension[]=} extensionsToReturn\n         * @param {import(\"./htmx\").HtmxExtension[]=} extensionsToIgnore\n         */\n         function getExtensions(elt, extensionsToReturn, extensionsToIgnore) {\n\n            if (elt == undefined) {\n                return extensionsToReturn;\n            }\n            if (extensionsToReturn == undefined) {\n                extensionsToReturn = [];\n            }\n            if (extensionsToIgnore == undefined) {\n                extensionsToIgnore = [];\n            }\n            var extensionsForElement = getAttributeValue(elt, \"hx-ext\");\n            if (extensionsForElement) {\n                forEach(extensionsForElement.split(\",\"), function(extensionName){\n                    extensionName = extensionName.replace(/ /g, '');\n                    if (extensionName.slice(0, 7) == \"ignore:\") {\n                        extensionsToIgnore.push(extensionName.slice(7));\n                        return;\n                    }\n                    if (extensionsToIgnore.indexOf(extensionName) < 0) {\n                        var extension = extensions[extensionName];\n                        if (extension && extensionsToReturn.indexOf(extension) < 0) {\n                            extensionsToReturn.push(extension);\n                        }\n                    }\n                });\n            }\n            return getExtensions(parentElt(elt), extensionsToReturn, extensionsToIgnore);\n        }\n\n        //====================================================================\n        // Initialization\n        //====================================================================\n\n        function ready(fn) {\n            if (getDocument().readyState !== 'loading') {\n                fn();\n            } else {\n                getDocument().addEventListener('DOMContentLoaded', fn);\n            }\n        }\n\n        function insertIndicatorStyles() {\n            if (htmx.config.includeIndicatorStyles !== false) {\n                getDocument().head.insertAdjacentHTML(\"beforeend\",\n                    \"<style>\\\n                      .\" + htmx.config.indicatorClass + \"{opacity:0;transition: opacity 200ms ease-in;}\\\n                      .\" + htmx.config.requestClass + \" .\" + htmx.config.indicatorClass + \"{opacity:1}\\\n                      .\" + htmx.config.requestClass + \".\" + htmx.config.indicatorClass + \"{opacity:1}\\\n                    </style>\");\n            }\n        }\n\n        function getMetaConfig() {\n            var element = getDocument().querySelector('meta[name=\"htmx-config\"]');\n            if (element) {\n                // @ts-ignore\n                return parseJSON(element.content);\n            } else {\n                return null;\n            }\n        }\n\n        function mergeMetaConfig() {\n            var metaConfig = getMetaConfig();\n            if (metaConfig) {\n                htmx.config = mergeObjects(htmx.config , metaConfig)\n            }\n        }\n\n        // initialize the document\n        ready(function () {\n            mergeMetaConfig();\n            insertIndicatorStyles();\n            var body = getDocument().body;\n            processNode(body);\n            var restoredElts = getDocument().querySelectorAll(\n                \"[hx-trigger='restored'],[data-hx-trigger='restored']\"\n            );\n            body.addEventListener(\"htmx:abort\", function (evt) {\n                var target = evt.target;\n                var internalData = getInternalData(target);\n                if (internalData && internalData.xhr) {\n                    internalData.xhr.abort();\n                }\n            });\n            window.onpopstate = function (event) {\n                if (event.state && event.state.htmx) {\n                    restoreHistory();\n                    forEach(restoredElts, function(elt){\n                        triggerEvent(elt, 'htmx:restored', {\n                            'document': getDocument(),\n                            'triggerEvent': triggerEvent\n                        });\n                    });\n                }\n            };\n            setTimeout(function () {\n                triggerEvent(body, 'htmx:load', {}); // give ready handlers a chance to load up before firing this event\n            }, 0);\n        })\n\n        return htmx;\n    }\n)()\n}));\n"],"names":["root","factory","self","this","htmx","onLoad","onLoadHelper","process","processNode","on","addEventListenerImpl","off","removeEventListenerImpl","trigger","triggerEvent","ajax","ajaxHelper","find","findAll","closest","values","elt","type","getInputValues","remove","removeElement","addClass","addClassToElement","removeClass","removeClassFromElement","toggleClass","toggleClassOnElement","takeClass","takeClassForElement","defineExtension","removeExtension","logAll","logger","config","historyEnabled","historyCacheSize","refreshOnHistoryMiss","defaultSwapStyle","defaultSwapDelay","defaultSettleDelay","includeIndicatorStyles","indicatorClass","requestClass","addedClass","settlingClass","swappingClass","allowEval","inlineScriptNonce","attributesToSettle","withCredentials","timeout","wsReconnectDelay","wsBinaryType","disableSelector","useTemplateFragments","scrollBehavior","defaultFocusScroll","getCacheBusterParam","parseInterval","_","internalEval","createEventSource","url","EventSource","createWebSocket","sock","WebSocket","binaryType","version","internalAPI","addTriggerHandler","bodyContains","canAccessLocalStorage","filterValues","hasAttribute","getAttributeValue","getClosestMatch","getExpressionVars","getHeaders","getInternalData","getSwapSpecification","getTriggerSpecs","getTarget","makeFragment","mergeObjects","makeSettleInfo","oobSwap","selectAndSwap","settleImmediately","shouldCancel","triggerErrorEvent","withExtensions","VERBS","VERB_SELECTOR","map","verb","join","str","undefined","slice","parseFloat","getRawAttribute","name","getAttribute","qualifiedName","parentElt","parentElement","getDocument","document","condition","getAttributeValueWithDisinheritance","initialElement","ancestor","attributeName","attributeValue","disinherit","split","indexOf","getClosestAttributeValue","closestAttr","e","matches","selector","matchesFunction","matchesSelector","msMatchesSelector","mozMatchesSelector","webkitMatchesSelector","oMatchesSelector","call","getStartTag","match","exec","toLowerCase","parseHTML","resp","depth","responseNode","DOMParser","parseFromString","body","firstChild","createDocumentFragment","querySelector","content","maybeCall","func","isType","o","Object","prototype","toString","isFunction","isRawObject","dataProp","data","toArray","arr","returnArr","i","length","push","forEach","isScrolledIntoView","el","rect","getBoundingClientRect","elemTop","top","elemBottom","bottom","window","innerHeight","getRootNode","ShadowRoot","contains","host","splitOnWhitespace","trim","obj1","obj2","key","hasOwnProperty","parseJSON","jString","JSON","parse","error","logError","test","localStorage","setItem","removeItem","maybeEval","eval","callback","evt","detail","event","console","log","eltOrSelector","querySelectorAll","delay","resolveTarget","setTimeout","removeChild","clazz","classList","add","removeAttribute","toggle","children","child","querySelectorAllExt","substr","scanForwardQuery","scanBackwardsQuery","start","results","compareDocumentPosition","Node","DOCUMENT_POSITION_PRECEDING","DOCUMENT_POSITION_FOLLOWING","querySelectorExt","arg2","processEventArgs","arg1","arg3","target","listener","ready","eventArgs","addEventListener","removeEventListener","DUMMY_ELT","createElement","findAttributeTargets","attrName","attrTarget","findThisElement","result","attribute","targetStr","boosted","shouldSettleAttribute","cloneAttributes","mergeTo","mergeFrom","attributes","attr","setAttribute","value","isInlineSwap","swapStyle","extensions","getExtensions","extension","oobValue","oobElement","settleInfo","id","targets","fragment","oobElementClone","cloneNode","appendChild","beforeSwapDetails","shouldSwap","swap","elts","parentNode","handleOutOfBandSwaps","oobSelects","oobSelectValues","oobSelectValue","substring","handlePreservedElements","preservedElt","oldElt","getElementById","replaceChild","handleAttributes","newNode","normalizedId","replace","oldNode","tagName","newAttributes","tasks","makeAjaxLoadTask","processScripts","processFocus","autofocus","autoFocusedElt","focus","insertNodesBefore","insertBefore","childNodes","nodeType","TEXT_NODE","COMMENT_NODE","stringHash","string","hash","char","charCodeAt","attributeHash","deInitNode","element","internalData","webSocket","close","sseEventSource","listenerInfos","info","cleanUpElement","swapOuterHTML","swapInnerHTML","newElt","eltBeforeNewContent","previousSibling","nextSibling","replacedWith","ELEMENT_NODE","nextElementSibling","swapAfterBegin","swapBeforeBegin","swapBeforeEnd","swapAfterEnd","swapDelete","maybeSelectFromResponse","newFragment","node","ext","newElements","handleSwap","j","findTitle","responseText","title","handleTrigger","xhr","header","triggerBody","getResponseHeader","triggers","eventName","WHITESPACE","WHITESPACE_OR_COMMA","SYMBOL_START","SYMBOL_CONT","STRINGISH_START","NOT_WHITESPACE","tokenizeString","tokens","position","charAt","startPosition","startChar","symbol","isPossibleRelativeReference","token","last","paramName","maybeGenerateConditional","shift","bracketCount","conditionalSource","conditionFunction","Function","source","consumeUntil","INPUT_SELECTOR","explicitTrigger","triggerSpecs","initialLength","every","pollInterval","eventFilter","sseEvent","triggerSpec","changed","once","consume","from_arg","from","throttle","queue","cancelPolling","cancelled","processPolling","handler","spec","nodeData","maybeFilterEvent","makeEvent","isLocalLink","location","hostname","boostElement","path","rawAttribute","issueAjaxRequest","href","ignoreBoostedAnchorCtrlClick","ctrlKey","metaKey","explicitCancel","eltsToListenOn","elementData","lastValue","eltToListenOn","eventListener","preventDefault","eventData","handledFor","stopPropagation","triggeredOnce","delayed","clearTimeout","windowIsScrolling","scrollHandler","initScrollHandler","setInterval","maybeReveal","initHash","processWebSocketInfo","ensureWebSocket","processWebSocketSend","wssSource","retryCount","base_part","port","protocol","socket","onerror","maybeCloseWebSocketSource","onclose","code","getWebSocketReconnectDelay","onopen","response","transformResponse","webSocketSourceElt","parent","headers","errors","filteredParameters","send","stringify","exp","Math","min","pow","random","processSSEInfo","processSSESource","processSSESwap","sseSrc","maybeCloseSSESource","sseEventName","sseSourceElt","hasEventSource","sseListener","swapSpec","processSSETrigger","loadImmediately","load","loaded","processVerbs","explicitAction","observerOptions","threshold","IntersectionObserver","entries","isIntersecting","observe","polling","evalScript","script","newScript","textContent","async","nonce","hasChanceOfBeingBoosted","findElementsToProcess","boostedElts","initButtonTracking","form","maybeSetLastButtonClicked","lastButtonClicked","initNode","sseInfo","wsInfo","kebabEventName","CustomEvent","bubbles","cancelable","createEvent","initCustomEvent","ignoreEventForLogging","toDo","msg","errorInfo","eventResult","dispatchEvent","kebabName","kebabedEvent","onEvent","currentPathForHistory","pathname","search","getHistoryElement","saveToHistoryCache","scroll","historyCache","getItem","splice","newHistoryItem","item","cache","cause","getCachedHistory","cleanInnerHtmlForHistory","className","clone","innerHTML","saveCurrentPageToHistory","historyElt","scrollY","history","replaceState","pushUrlIntoHistory","endsWith","pushState","replaceUrlInHistory","task","loadHistoryFromServer","request","XMLHttpRequest","details","open","setRequestHeader","onload","status","historyElement","titleElt","cacheMiss","serverResponse","restoreHistory","cached","scrollTo","reload","addRequestIndicatorClasses","indicators","ic","requestCount","removeRequestIndicatorClasses","haveSeenNode","processed","isSameNode","shouldInclude","disabled","checked","processInputValue","validate","multiple","files","current","Array","isArray","concat","validateElement","elements","input","willValidate","checkValidity","message","validationMessage","validity","formValues","noValidate","formNoValidate","descendant","appendParam","returnStr","realValue","String","s","encodeURIComponent","urlEncode","v","makeFormData","formData","FormData","append","prompt1","getValuesForElement","inputValues","paramsValue","newValues","isAnchorLink","swapInfoOverride","swapInfo","swapDelay","settleDelay","modifier","scrollVal","splitSpec","pop","selectorVal","showVal","focusScrollVal","usesFormData","encodeParamsForBody","encodedParameters","encodeParameters","updateScrollState","first","scrollTarget","scrollTop","scrollHeight","show","showTarget","scrollIntoView","block","behavior","evalAsDefault","varsValues","evaluateValue","toEval","defaultVal","getHXVarsForElement","expressionVars","getHXValsForElement","safelySetHeaderValue","headerValue","getPathFromResponse","responseURL","URL","hasHeader","regexp","getAllResponseHeaders","context","Element","targetOverride","returnPromise","swapOverride","hierarchyForElt","etc","confirmed","resolve","reject","Promise","promise","_resolve","_reject","responseHandler","handleAjaxResponse","triggeringEvent","issueRequest","syncElt","eltData","syncStrategy","queueStrategy","abortable","syncStrings","queuedRequests","endRequestLock","queuedRequest","promptQuestion","promptResponse","prompt","confirmQuestion","confirm","rawParameters","allParameters","requestAttrValues","eltIsBoosted","requestConfig","parameters","unfilteredParameters","credentials","splitPath","pathNoAnchor","anchor","finalPathForGet","keys","toUpperCase","overrideMimeType","noHeaders","responseInfo","pathInfo","requestPath","finalRequestPath","hierarchy","responsePath","secondaryTriggerElt","parentEltInHierarchy","onabort","ontimeout","upload","lengthComputable","total","determineHistoryUpdates","pathFromHeaders","typeFromHeaders","pushUrl","replaceUrl","elementIsBoosted","saveType","redirectPath","then","historyUpdate","isError","failed","successful","doSwap","activeElt","activeElement","selectionInfo","selectionStart","end","selectionEnd","newActiveElt","focusOptions","preventScroll","focusScroll","setSelectionRange","finalElt","doSettle","anchorTarget","extensionBase","init","api","text","extensionsToReturn","extensionsToIgnore","extensionsForElement","extensionName","fn","readyState","insertIndicatorStyles","head","insertAdjacentHTML","getMetaConfig","mergeMetaConfig","metaConfig","restoredElts","abort","onpopstate","state","define","amd","module","exports"],"version":3,"file":"htmx.js.map"}